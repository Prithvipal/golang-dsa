{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Data Structures and Algorithms using Golang Data Structures and Algorithms using Golang provides solution code in golang for DSA. It shows time and space complexity for each solution. It does not explain theoretical concepts of DSA but providers different level(Naive, Efficient and More Efficient) of programming solution for problem statement.","title":"Home"},{"location":"#data-structures-and-algorithms-using-golang","text":"Data Structures and Algorithms using Golang provides solution code in golang for DSA. It shows time and space complexity for each solution. It does not explain theoretical concepts of DSA but providers different level(Naive, Efficient and More Efficient) of programming solution for problem statement.","title":"Data Structures and Algorithms using Golang"},{"location":"about/","text":"About Prithvipal Singh Prithvipal Singh is software engineer having more than 8 years of experience. He is experience in Golang, Java, Kubernetes, Docker, Microservice architecture, Cloud Computing. Currently, he is exploring edge computing. He looks to contribute in open source code. He is an author of Hands on go programming book. Social Media Let us connect. LinkedIn: https://www.linkedin.com/in/prithvipal-singh-2a7b4b49/ Twiter: https://twitter.com/prithvirathor99","title":"About"},{"location":"about/#about-prithvipal-singh","text":"Prithvipal Singh is software engineer having more than 8 years of experience. He is experience in Golang, Java, Kubernetes, Docker, Microservice architecture, Cloud Computing. Currently, he is exploring edge computing. He looks to contribute in open source code. He is an author of Hands on go programming book.","title":"About Prithvipal Singh"},{"location":"about/#social-media","text":"Let us connect. LinkedIn: https://www.linkedin.com/in/prithvipal-singh-2a7b4b49/ Twiter: https://twitter.com/prithvirathor99","title":"Social Media"},{"location":"array/intro/","text":"Introduction of Array Continuous memory allocation Advantages Random Access Cache friendliness","title":"Introduction"},{"location":"array/intro/#introduction-of-array","text":"Continuous memory allocation Advantages Random Access Cache friendliness","title":"Introduction of Array"},{"location":"array/is_array_sorted/","text":"Check If An Array is Sorted Input: arr[] = {18, 25, 27} Output: Yes Input: arr[] = {18, 30, 30, 99} Output: Yes Input: arr[] = {100} Output: Yes Input: arr[] = {100, 20, 200} Output: No Note - We are only considering array wheree array are in assending order - It there are duplicate then is also true. Ex. 2nd example above Naive Approach package main import ( \"fmt\" ) func main() { arr := []int{18, 25, 27} // Yes // arr := []int{18, 30, 30, 99} // Yes // arr := []int{100} // Yes // arr := []int{100, 20, 200} // No result := isArraySorted(arr) if result { fmt.Println(\"Yes\") } else { fmt.Println(\"No\") } } func isArraySorted(arr []int) bool { for i := 0; i < len(arr); i++ { for j := i + 1; j < len(arr); j++ { if arr[i] > arr[j] { return false } } } return true } Time Complexity: O(n2) Efficient Approach package main import ( \"fmt\" ) func main() { // arr := []int{18, 25, 27} // Yes // arr := []int{18, 30, 30, 99} // Yes // arr := []int{100} // Yes arr := []int{100, 20, 200} // No result := isArraySorted(arr) if result { fmt.Println(\"Yes\") } else { fmt.Println(\"No\") } } func isArraySorted(arr []int) bool { for i := 0; i < len(arr)-2; i++ { if arr[i] > arr[i+1] { return false } } return true } Time Complexity: O(n)","title":"Check If Array is Sorted"},{"location":"array/is_array_sorted/#check-if-an-array-is-sorted","text":"Input: arr[] = {18, 25, 27} Output: Yes Input: arr[] = {18, 30, 30, 99} Output: Yes Input: arr[] = {100} Output: Yes Input: arr[] = {100, 20, 200} Output: No Note - We are only considering array wheree array are in assending order - It there are duplicate then is also true. Ex. 2nd example above","title":"Check If An Array is Sorted"},{"location":"array/is_array_sorted/#naive-approach","text":"package main import ( \"fmt\" ) func main() { arr := []int{18, 25, 27} // Yes // arr := []int{18, 30, 30, 99} // Yes // arr := []int{100} // Yes // arr := []int{100, 20, 200} // No result := isArraySorted(arr) if result { fmt.Println(\"Yes\") } else { fmt.Println(\"No\") } } func isArraySorted(arr []int) bool { for i := 0; i < len(arr); i++ { for j := i + 1; j < len(arr); j++ { if arr[i] > arr[j] { return false } } } return true } Time Complexity: O(n2)","title":"Naive Approach"},{"location":"array/is_array_sorted/#efficient-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{18, 25, 27} // Yes // arr := []int{18, 30, 30, 99} // Yes // arr := []int{100} // Yes arr := []int{100, 20, 200} // No result := isArraySorted(arr) if result { fmt.Println(\"Yes\") } else { fmt.Println(\"No\") } } func isArraySorted(arr []int) bool { for i := 0; i < len(arr)-2; i++ { if arr[i] > arr[i+1] { return false } } return true } Time Complexity: O(n)","title":"Efficient Approach"},{"location":"array/largest_element/","text":"Largest element in array package main import \"fmt\" func main() { arr := []int{10, 52, 18, 20} largest := getLargest(arr) fmt.Println(\"largest element at index\", largest) fmt.Println(\"largest element\", arr[largest]) } func getLargest(arr []int) int { largest := 0 for i := 1; i < len(arr); i++ { if arr[i] > arr[largest] { largest = i } } return largest } Time Complexity: O(n)","title":"Largest Element in Array"},{"location":"array/largest_element/#largest-element-in-array","text":"package main import \"fmt\" func main() { arr := []int{10, 52, 18, 20} largest := getLargest(arr) fmt.Println(\"largest element at index\", largest) fmt.Println(\"largest element\", arr[largest]) } func getLargest(arr []int) int { largest := 0 for i := 1; i < len(arr); i++ { if arr[i] > arr[largest] { largest = i } } return largest } Time Complexity: O(n)","title":"Largest element in array"},{"location":"array/move_all_zeroes_to_end/","text":"Move All Zeroes to End Input: arr[] = {18, 13, 0, 30, 0, 40} Output: arr[] = {18, 13, 30, 40, 0, 0} Input: arr[] = {0, 0, 0, 20, 0} Output: arr[] = {20, 0, 0, 0} Input: arr[] = {50, 66} Output: arr[] = {50, 66} Noive Approach","title":"Move All Zeroes to End"},{"location":"array/move_all_zeroes_to_end/#move-all-zeroes-to-end","text":"Input: arr[] = {18, 13, 0, 30, 0, 40} Output: arr[] = {18, 13, 30, 40, 0, 0} Input: arr[] = {0, 0, 0, 20, 0} Output: arr[] = {20, 0, 0, 0} Input: arr[] = {50, 66} Output: arr[] = {50, 66}","title":"Move All Zeroes to End"},{"location":"array/move_all_zeroes_to_end/#noive-approach","text":"","title":"Noive Approach"},{"location":"array/operations/","text":"Operations Search (unsorted array) package main import \"fmt\" func main() { arr := []int{10, 3, 6, 14, 17} result := search(arr, 14) if result == -1 { fmt.Println(\"Element not found\") } else { fmt.Println(\"Element found at index:\", result) } } func search(arr []int, ele int) int { for i := 0; i < len(arr); i++ { if arr[i] == ele { return i } } return -1 } Time Complexity: O(n)","title":"Operation in Array"},{"location":"array/operations/#operations","text":"","title":"Operations"},{"location":"array/operations/#search-unsorted-array","text":"package main import \"fmt\" func main() { arr := []int{10, 3, 6, 14, 17} result := search(arr, 14) if result == -1 { fmt.Println(\"Element not found\") } else { fmt.Println(\"Element found at index:\", result) } } func search(arr []int, ele int) int { for i := 0; i < len(arr); i++ { if arr[i] == ele { return i } } return -1 } Time Complexity: O(n)","title":"Search (unsorted array)"},{"location":"array/remove_duplicates_from_sorted_array/","text":"Remove Duplicates from Sorted Array Input: arr[] = {12, 15, 15, 20, 20, 20, 20} length: 7 Output: arr[] = {12, 15, 20} length: 3 Input: arr[] = {16, 16, 16} length: 3 Output: arr[] = {16} length: 1 Naive Approach package main import ( \"fmt\" ) func main() { // arr := []int{12, 15, 15, 20, 20, 20, 20} // [12 15 20] arr := []int{16, 16, 16} // [16] result := removeDups(arr) fmt.Println(\"arr[] =\", result) fmt.Println(\"length =\", len(result)) } func removeDups(arr []int) []int { var temp []int temp = append(temp, arr[0]) result := 1 for i := 1; i < len(arr); i++ { if temp[result-1] != arr[i] { temp = append(temp, arr[i]) result++ } } for i := 0; i < result; i++ { arr[i] = temp[i] } return arr[:result] } Time Complexity: O(n) Space Complexity: O(n) Efficient Approach package main import ( \"fmt\" ) func main() { // arr := []int{12, 15, 15, 20, 20, 20, 20} // [12 15 20] arr := []int{16, 16, 16} // [16] result := removeDups(arr) fmt.Println(\"arr[] =\", result) fmt.Println(\"length =\", len(result)) } func removeDups(arr []int) []int { result := 1 for i := 1; i < len(arr); i++ { if arr[i] != arr[result-1] { arr[result] = arr[i] result++ } } return arr[:result] } Time Complexity: O(n) Space Complexity: O(1) Note: we are using result variable to keep track to unique elements in array.","title":"Remove Duplicate from Sorted Array"},{"location":"array/remove_duplicates_from_sorted_array/#remove-duplicates-from-sorted-array","text":"Input: arr[] = {12, 15, 15, 20, 20, 20, 20} length: 7 Output: arr[] = {12, 15, 20} length: 3 Input: arr[] = {16, 16, 16} length: 3 Output: arr[] = {16} length: 1","title":"Remove Duplicates from Sorted Array"},{"location":"array/remove_duplicates_from_sorted_array/#naive-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{12, 15, 15, 20, 20, 20, 20} // [12 15 20] arr := []int{16, 16, 16} // [16] result := removeDups(arr) fmt.Println(\"arr[] =\", result) fmt.Println(\"length =\", len(result)) } func removeDups(arr []int) []int { var temp []int temp = append(temp, arr[0]) result := 1 for i := 1; i < len(arr); i++ { if temp[result-1] != arr[i] { temp = append(temp, arr[i]) result++ } } for i := 0; i < result; i++ { arr[i] = temp[i] } return arr[:result] } Time Complexity: O(n) Space Complexity: O(n)","title":"Naive Approach"},{"location":"array/remove_duplicates_from_sorted_array/#efficient-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{12, 15, 15, 20, 20, 20, 20} // [12 15 20] arr := []int{16, 16, 16} // [16] result := removeDups(arr) fmt.Println(\"arr[] =\", result) fmt.Println(\"length =\", len(result)) } func removeDups(arr []int) []int { result := 1 for i := 1; i < len(arr); i++ { if arr[i] != arr[result-1] { arr[result] = arr[i] result++ } } return arr[:result] } Time Complexity: O(n) Space Complexity: O(1) Note: we are using result variable to keep track to unique elements in array.","title":"Efficient Approach"},{"location":"array/reverse_array/","text":"Reverse an Array Input: arr[] = {12, 7, 9, 33} Output arr[] = {33, 9, 7, 12} Input: arr[] = {33, 22, 9, 3, 99} Output: arr[] = {99, 3, 9, 22, 33} Approach One package main import ( \"fmt\" ) func main() { arr := []int{12, 7, 9, 33} // [33 9 7 12] // arr := []int{33, 22, 9, 3, 99} // [99 3 9 22 33 reserveArray(arr) fmt.Println(arr) } func reserveArray(arr []int) { low := 0 high := len(arr) - 1 for low < high { temp := arr[low] arr[low] = arr[high] arr[high] = temp low++ high-- } } Time Complexity: : \u03b8(n) Aux Space: \u03b8(1) Approach Two package main import ( \"fmt\" ) func main() { // arr := []int{12, 7, 9, 33} // [33 9 7 12] arr := []int{33, 22, 9, 3, 99} // [99 3 9 22 33 reverseArray(arr) fmt.Println(arr) } func reverseArray(arr []int) { for i := 0; i < len(arr)/2; i++ { temp := arr[i] j := len(arr) - i - 1 arr[i] = arr[j] arr[j] = temp } } Time Complexity: : \u03b8(n) Aux Space: \u03b8(1)","title":"Reverse an Array"},{"location":"array/reverse_array/#reverse-an-array","text":"Input: arr[] = {12, 7, 9, 33} Output arr[] = {33, 9, 7, 12} Input: arr[] = {33, 22, 9, 3, 99} Output: arr[] = {99, 3, 9, 22, 33}","title":"Reverse an Array"},{"location":"array/reverse_array/#approach-one","text":"package main import ( \"fmt\" ) func main() { arr := []int{12, 7, 9, 33} // [33 9 7 12] // arr := []int{33, 22, 9, 3, 99} // [99 3 9 22 33 reserveArray(arr) fmt.Println(arr) } func reserveArray(arr []int) { low := 0 high := len(arr) - 1 for low < high { temp := arr[low] arr[low] = arr[high] arr[high] = temp low++ high-- } } Time Complexity: : \u03b8(n) Aux Space: \u03b8(1)","title":"Approach One"},{"location":"array/reverse_array/#approach-two","text":"package main import ( \"fmt\" ) func main() { // arr := []int{12, 7, 9, 33} // [33 9 7 12] arr := []int{33, 22, 9, 3, 99} // [99 3 9 22 33 reverseArray(arr) fmt.Println(arr) } func reverseArray(arr []int) { for i := 0; i < len(arr)/2; i++ { temp := arr[i] j := len(arr) - i - 1 arr[i] = arr[j] arr[j] = temp } } Time Complexity: : \u03b8(n) Aux Space: \u03b8(1)","title":"Approach Two"},{"location":"array/second_largest_element/","text":"Second Largest Element in Array Input: arr[] = {10, 5, 6, 15} Output: 0 // index of 10 Input: arr[] = {30, 15, 23, 9, 28} Output: 4 // index of 28 Inpute: arr[] = {15, 15, 15} Output: -1 // No second element Naive Approach package main import ( \"fmt\" ) func main() { // arr := []int{10, 5, 6, 15} // arr := []int{30, 15, 23, 9, 28} arr := []int{15, 15, 15} secLargest := getSecondLargest(arr) if secLargest == -1 { fmt.Println(\"No sencond largest found\") } else { fmt.Println(\"largest element at index\", secLargest) fmt.Println(\"largest element\", arr[secLargest]) } } func getLargest(arr []int) int { largest := 0 for i := 1; i < len(arr); i++ { if arr[i] > arr[largest] { largest = i } } return largest } func getSecondLargest(arr []int) int { first := getLargest(arr) second := -1 for i := 0; i < len(arr); i++ { if arr[first] != arr[i] { if second == -1 { second = i } else if arr[second] < arr[i] { second = i } } } return second } Efficient Approach arr[i] > arr[largest]: res = largest, largest = i arr[i] == arr[largest]: Ignore arr[i] < arr[largest]: res == -1: res = i arr[i] <= arr[res]: Ignore arr[i] > arr[res]: res = i package main import ( \"fmt\" ) func main() { arr := []int{10, 5, 6, 15} // arr := []int{30, 15, 23, 9, 28} // arr := []int{15, 15, 15} secLargest := getSecondLargest(arr) if secLargest == -1 { fmt.Println(\"No sencond largest found\") } else { fmt.Println(\"largest element at index\", secLargest) fmt.Println(\"largest element\", arr[secLargest]) } } func getSecondLargest(arr []int) int { first := 0 second := -1 for i := 1; i < len(arr); i++ { if arr[i] > arr[first] { second = first first = i } else if (second == -1 || arr[i] > arr[second]) && arr[i] != arr[first] { second = i } } return second } Time Complexity: O(n)","title":"Second Largest Element in Array"},{"location":"array/second_largest_element/#second-largest-element-in-array","text":"Input: arr[] = {10, 5, 6, 15} Output: 0 // index of 10 Input: arr[] = {30, 15, 23, 9, 28} Output: 4 // index of 28 Inpute: arr[] = {15, 15, 15} Output: -1 // No second element","title":"Second Largest Element in Array"},{"location":"array/second_largest_element/#naive-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{10, 5, 6, 15} // arr := []int{30, 15, 23, 9, 28} arr := []int{15, 15, 15} secLargest := getSecondLargest(arr) if secLargest == -1 { fmt.Println(\"No sencond largest found\") } else { fmt.Println(\"largest element at index\", secLargest) fmt.Println(\"largest element\", arr[secLargest]) } } func getLargest(arr []int) int { largest := 0 for i := 1; i < len(arr); i++ { if arr[i] > arr[largest] { largest = i } } return largest } func getSecondLargest(arr []int) int { first := getLargest(arr) second := -1 for i := 0; i < len(arr); i++ { if arr[first] != arr[i] { if second == -1 { second = i } else if arr[second] < arr[i] { second = i } } } return second }","title":"Naive Approach"},{"location":"array/second_largest_element/#efficient-approach","text":"arr[i] > arr[largest]: res = largest, largest = i arr[i] == arr[largest]: Ignore arr[i] < arr[largest]: res == -1: res = i arr[i] <= arr[res]: Ignore arr[i] > arr[res]: res = i package main import ( \"fmt\" ) func main() { arr := []int{10, 5, 6, 15} // arr := []int{30, 15, 23, 9, 28} // arr := []int{15, 15, 15} secLargest := getSecondLargest(arr) if secLargest == -1 { fmt.Println(\"No sencond largest found\") } else { fmt.Println(\"largest element at index\", secLargest) fmt.Println(\"largest element\", arr[secLargest]) } } func getSecondLargest(arr []int) int { first := 0 second := -1 for i := 1; i < len(arr); i++ { if arr[i] > arr[first] { second = first first = i } else if (second == -1 || arr[i] > arr[second]) && arr[i] != arr[first] { second = i } } return second } Time Complexity: O(n)","title":"Efficient Approach"}]}