{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Data Structures and Algorithms using Golang Data Structures and Algorithms using Golang provides code implemention for DSA problem statements in golang . It shows time and space complexity for each solution. It does not explain theoretical concepts of DSA but providers different level(Naive, Efficient and More Efficient) of programming solution for problem statement.","title":"Home"},{"location":"index.html#data-structures-and-algorithms-using-golang","text":"Data Structures and Algorithms using Golang provides code implemention for DSA problem statements in golang . It shows time and space complexity for each solution. It does not explain theoretical concepts of DSA but providers different level(Naive, Efficient and More Efficient) of programming solution for problem statement.","title":"Data Structures and Algorithms using Golang"},{"location":"about.html","text":"About Prithvipal Singh Prithvipal Singh is software engineer having more than 8 years of experience. He is experience in Golang, Java, Kubernetes, Docker, Microservice architecture, Cloud Computing. Currently, he is exploring edge computing. He looks to contribute in open source code. He is an author of Hands on go programming book. Social Media Let us connect. LinkedIn: https://www.linkedin.com/in/prithvipal-singh-2a7b4b49/ Twiter: https://twitter.com/prithvirathor99","title":"About"},{"location":"about.html#about-prithvipal-singh","text":"Prithvipal Singh is software engineer having more than 8 years of experience. He is experience in Golang, Java, Kubernetes, Docker, Microservice architecture, Cloud Computing. Currently, he is exploring edge computing. He looks to contribute in open source code. He is an author of Hands on go programming book.","title":"About Prithvipal Singh"},{"location":"about.html#social-media","text":"Let us connect. LinkedIn: https://www.linkedin.com/in/prithvipal-singh-2a7b4b49/ Twiter: https://twitter.com/prithvirathor99","title":"Social Media"},{"location":"array/frequency_sorted_array.html","text":"Frequency in a Sorted Array Input: arr[] = {12, 12, 12, 23, 43, 43} Output: 12 -> 3 23 -> 1 43 -> 2 Input: arr[] = {14, 14, 14, 14} Output: 14 -> 4 Input: arr[] = {101, 102, 103} Output: 101 -> 1 102 -> 1 103 -> 1 Implementation package main import \"fmt\" func main() { arr := []int{10} // arr := []int{12, 12, 12, 23, 43, 43} // arr := []int{14, 14, 14, 14} // arr := []int{101, 102, 103} printFreq(arr) } func printFreq(arr []int) { freq := 1 i := 1 for i < len(arr) { for i < len(arr) && arr[i] == arr[i-1] { i++ freq++ } fmt.Printf(\"%d -> %d\\n\", arr[i-1], freq) i++ freq = 1 } if len(arr) == 1 || arr[i-2] != arr[i-3] { fmt.Printf(\"%d --> %d\\n\", arr[len(arr)-1], 1) } } Time Complexity: \u03b8(n) Note: Since we are increamenting i in both for loop (outer and inner). As soon as i becomes equal to n, the loop stops. So total number of iterations are inner+outer loops. Time complexity is exactly n.","title":"Frequency in Sorted Array"},{"location":"array/frequency_sorted_array.html#frequency-in-a-sorted-array","text":"Input: arr[] = {12, 12, 12, 23, 43, 43} Output: 12 -> 3 23 -> 1 43 -> 2 Input: arr[] = {14, 14, 14, 14} Output: 14 -> 4 Input: arr[] = {101, 102, 103} Output: 101 -> 1 102 -> 1 103 -> 1","title":"Frequency in a Sorted Array"},{"location":"array/frequency_sorted_array.html#implementation","text":"package main import \"fmt\" func main() { arr := []int{10} // arr := []int{12, 12, 12, 23, 43, 43} // arr := []int{14, 14, 14, 14} // arr := []int{101, 102, 103} printFreq(arr) } func printFreq(arr []int) { freq := 1 i := 1 for i < len(arr) { for i < len(arr) && arr[i] == arr[i-1] { i++ freq++ } fmt.Printf(\"%d -> %d\\n\", arr[i-1], freq) i++ freq = 1 } if len(arr) == 1 || arr[i-2] != arr[i-3] { fmt.Printf(\"%d --> %d\\n\", arr[len(arr)-1], 1) } } Time Complexity: \u03b8(n) Note: Since we are increamenting i in both for loop (outer and inner). As soon as i becomes equal to n, the loop stops. So total number of iterations are inner+outer loops. Time complexity is exactly n.","title":"Implementation"},{"location":"array/intersection_of_two_sorted_array.html","text":"Intersection of Two Sorted Array Input: a[] = {4, 6, 12, 12, 12, 17, 17, 34} b[] = { 6, 12, 13, 17, 40} Output: c[] = { 6, 12, 17} Input: a[] = {2, 2, 4, 4, 4} b[] = {2, 2, 2, 2, 4, 6, 7} Output: c[] = {2, 4} Naive Solution package main import \"fmt\" func main() { a := []int{3, 5, 10, 10, 10, 15, 15, 20} b := []int{5, 10, 10, 15, 30} res := intersection(a, b) fmt.Println(res) //[5 10 15] } func intersection(a, b []int) (c []int) { for i := 0; i < len(a); i++ { if i > 0 && a[i] == a[i-1] { continue } for j := 0; j < len(b); j++ { if a[i] == b[j] { c = append(c, a[i]) break } } } return c } Time Complexity: O(m*n) Dry Run: a[] = {1, 20, 20, 40, 60} b[] = {2, 20, 20, 20} i=0 : j=0, 1, 2, 3 i=1 : j=0, 1 c[] = {20} i=2 : i=3 : j = 0, 1, 2, 3 i=4 : j = 0, 1, 2, 3 Efficient Solution package main import \"fmt\" func main() { a := []int{3, 5, 10, 10, 10, 15, 15, 20} b := []int{5, 10, 10, 15, 30} res := intersection(a, b) fmt.Println(res) //[5 10 15] } func intersection(a, b []int) (c []int) { i := 0 j := 0 for i < len(a) && j < len(b) { if i > 0 && a[i-1] == a[i] { i++ continue } if a[i] < b[j] { i++ } else if a[i] > b[j] { j++ } else { c = append(c, a[i]) i++ j++ } } return c } Time Complexity: \u03b8(m+n) Dry Run: a[] = {10, 20, 20, 40, 60} b[] = {2, 20, 20, 20} Initially: i=0, j=0 1st Iteration: j=1 2nd Iteration: i=1 3rd Iteration: c[20], i=2, j=2 4th Iteration: i=3 5th Iteration: j=3 6th Iteration: j=4","title":"Intersection of Two Sorted Array"},{"location":"array/intersection_of_two_sorted_array.html#intersection-of-two-sorted-array","text":"Input: a[] = {4, 6, 12, 12, 12, 17, 17, 34} b[] = { 6, 12, 13, 17, 40} Output: c[] = { 6, 12, 17} Input: a[] = {2, 2, 4, 4, 4} b[] = {2, 2, 2, 2, 4, 6, 7} Output: c[] = {2, 4}","title":"Intersection of Two Sorted Array"},{"location":"array/intersection_of_two_sorted_array.html#naive-solution","text":"package main import \"fmt\" func main() { a := []int{3, 5, 10, 10, 10, 15, 15, 20} b := []int{5, 10, 10, 15, 30} res := intersection(a, b) fmt.Println(res) //[5 10 15] } func intersection(a, b []int) (c []int) { for i := 0; i < len(a); i++ { if i > 0 && a[i] == a[i-1] { continue } for j := 0; j < len(b); j++ { if a[i] == b[j] { c = append(c, a[i]) break } } } return c } Time Complexity: O(m*n) Dry Run: a[] = {1, 20, 20, 40, 60} b[] = {2, 20, 20, 20} i=0 : j=0, 1, 2, 3 i=1 : j=0, 1 c[] = {20} i=2 : i=3 : j = 0, 1, 2, 3 i=4 : j = 0, 1, 2, 3","title":"Naive Solution"},{"location":"array/intersection_of_two_sorted_array.html#efficient-solution","text":"package main import \"fmt\" func main() { a := []int{3, 5, 10, 10, 10, 15, 15, 20} b := []int{5, 10, 10, 15, 30} res := intersection(a, b) fmt.Println(res) //[5 10 15] } func intersection(a, b []int) (c []int) { i := 0 j := 0 for i < len(a) && j < len(b) { if i > 0 && a[i-1] == a[i] { i++ continue } if a[i] < b[j] { i++ } else if a[i] > b[j] { j++ } else { c = append(c, a[i]) i++ j++ } } return c } Time Complexity: \u03b8(m+n) Dry Run: a[] = {10, 20, 20, 40, 60} b[] = {2, 20, 20, 20} Initially: i=0, j=0 1st Iteration: j=1 2nd Iteration: i=1 3rd Iteration: c[20], i=2, j=2 4th Iteration: i=3 5th Iteration: j=3 6th Iteration: j=4","title":"Efficient Solution"},{"location":"array/intro.html","text":"Introduction of Array Continuous memory allocation Advantages Random Access Cache friendliness","title":"Introduction"},{"location":"array/intro.html#introduction-of-array","text":"Continuous memory allocation Advantages Random Access Cache friendliness","title":"Introduction of Array"},{"location":"array/is_array_sorted.html","text":"Check If An Array is Sorted Input: arr[] = {18, 25, 27} Output: Yes Input: arr[] = {18, 30, 30, 99} Output: Yes Input: arr[] = {100} Output: Yes Input: arr[] = {100, 20, 200} Output: No Note - We are only considering array wheree array are in assending order - It there are duplicate then is also true. Ex. 2nd example above Naive Approach package main import ( \"fmt\" ) func main() { arr := []int{18, 25, 27} // Yes // arr := []int{18, 30, 30, 99} // Yes // arr := []int{100} // Yes // arr := []int{100, 20, 200} // No result := isArraySorted(arr) if result { fmt.Println(\"Yes\") } else { fmt.Println(\"No\") } } func isArraySorted(arr []int) bool { for i := 0; i < len(arr); i++ { for j := i + 1; j < len(arr); j++ { if arr[i] > arr[j] { return false } } } return true } Time Complexity: O(n2) Efficient Approach package main import ( \"fmt\" ) func main() { // arr := []int{18, 25, 27} // Yes // arr := []int{18, 30, 30, 99} // Yes // arr := []int{100} // Yes arr := []int{100, 20, 200} // No result := isArraySorted(arr) if result { fmt.Println(\"Yes\") } else { fmt.Println(\"No\") } } func isArraySorted(arr []int) bool { for i := 0; i < len(arr)-2; i++ { if arr[i] > arr[i+1] { return false } } return true } Time Complexity: O(n)","title":"Check If Array is Sorted"},{"location":"array/is_array_sorted.html#check-if-an-array-is-sorted","text":"Input: arr[] = {18, 25, 27} Output: Yes Input: arr[] = {18, 30, 30, 99} Output: Yes Input: arr[] = {100} Output: Yes Input: arr[] = {100, 20, 200} Output: No Note - We are only considering array wheree array are in assending order - It there are duplicate then is also true. Ex. 2nd example above","title":"Check If An Array is Sorted"},{"location":"array/is_array_sorted.html#naive-approach","text":"package main import ( \"fmt\" ) func main() { arr := []int{18, 25, 27} // Yes // arr := []int{18, 30, 30, 99} // Yes // arr := []int{100} // Yes // arr := []int{100, 20, 200} // No result := isArraySorted(arr) if result { fmt.Println(\"Yes\") } else { fmt.Println(\"No\") } } func isArraySorted(arr []int) bool { for i := 0; i < len(arr); i++ { for j := i + 1; j < len(arr); j++ { if arr[i] > arr[j] { return false } } } return true } Time Complexity: O(n2)","title":"Naive Approach"},{"location":"array/is_array_sorted.html#efficient-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{18, 25, 27} // Yes // arr := []int{18, 30, 30, 99} // Yes // arr := []int{100} // Yes arr := []int{100, 20, 200} // No result := isArraySorted(arr) if result { fmt.Println(\"Yes\") } else { fmt.Println(\"No\") } } func isArraySorted(arr []int) bool { for i := 0; i < len(arr)-2; i++ { if arr[i] > arr[i+1] { return false } } return true } Time Complexity: O(n)","title":"Efficient Approach"},{"location":"array/largest_element.html","text":"Largest element in array package main import \"fmt\" func main() { arr := []int{10, 52, 18, 20} largest := getLargest(arr) fmt.Println(\"largest element at index\", largest) fmt.Println(\"largest element\", arr[largest]) } func getLargest(arr []int) int { largest := 0 for i := 1; i < len(arr); i++ { if arr[i] > arr[largest] { largest = i } } return largest } Time Complexity: O(n)","title":"Largest Element in Array"},{"location":"array/largest_element.html#largest-element-in-array","text":"package main import \"fmt\" func main() { arr := []int{10, 52, 18, 20} largest := getLargest(arr) fmt.Println(\"largest element at index\", largest) fmt.Println(\"largest element\", arr[largest]) } func getLargest(arr []int) int { largest := 0 for i := 1; i < len(arr); i++ { if arr[i] > arr[largest] { largest = i } } return largest } Time Complexity: O(n)","title":"Largest element in array"},{"location":"array/leaders_in_array.html","text":"Leaders in an Array Input: arr[] = {17, 20, 14, 13, 16, 15, 12} Output: {20, 16, 15, 12} Input: arr[] = {10, 20, 30} Output: {30} Input: arr[] = {25, 15, 10} Output: {25, 15, 10} Leader in an array is the element that there is no larger than the element to its right side. Left most is always be leader because there is no large then that element to its right side. If there are duplicate elements then first occurance can be considers as leader. We can consider last occurance because we are say larger but not equal. Ex: {9, 11, 6, 11, 8, 7, 2} :: here can not consider 11 of 1st index. we can condier 11 of 3rd index. Naive Approach package main import ( \"fmt\" ) func main() { // arr := []int{17, 20, 14, 13, 16, 15, 12} // 20 16 15 12 // arr := []int{10, 20, 30} // 30 arr := []int{25, 15, 10} leader(arr) } func leader(arr []int) { for i := 0; i < len(arr); i++ { flag := false for j := i + 1; j < len(arr); j++ { if arr[i] <= arr[j] { flag = true break } } if !flag { fmt.Printf(\"%d \", arr[i]) } } fmt.Println() } Time Complexity: O(n 2 ) Efficient Approach package main import ( \"fmt\" ) func main() { arr := []int{17, 20, 14, 13, 16, 15, 12} // 12 15 16 20 // arr := []int{10, 20, 30} // 30 // arr := []int{25, 15, 10} // 10 15 25 leader(arr) } func leader(arr []int) { curLeader := arr[len(arr)-1] fmt.Printf(\"%d \", curLeader) for i := len(arr) - 2; i >= 0; i-- { if curLeader < arr[i] { curLeader = arr[i] fmt.Printf(\"%d \", curLeader) } } fmt.Println() } Time Complexity: \u03b8(n) Note: It will print leaders in reverse order If we want to print in same order as we have in array, then we can store leaders in a new array and then we can iterate new array in reverse order and print each element.","title":"Leaders in Array"},{"location":"array/leaders_in_array.html#leaders-in-an-array","text":"Input: arr[] = {17, 20, 14, 13, 16, 15, 12} Output: {20, 16, 15, 12} Input: arr[] = {10, 20, 30} Output: {30} Input: arr[] = {25, 15, 10} Output: {25, 15, 10} Leader in an array is the element that there is no larger than the element to its right side. Left most is always be leader because there is no large then that element to its right side. If there are duplicate elements then first occurance can be considers as leader. We can consider last occurance because we are say larger but not equal. Ex: {9, 11, 6, 11, 8, 7, 2} :: here can not consider 11 of 1st index. we can condier 11 of 3rd index.","title":"Leaders in an Array"},{"location":"array/leaders_in_array.html#naive-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{17, 20, 14, 13, 16, 15, 12} // 20 16 15 12 // arr := []int{10, 20, 30} // 30 arr := []int{25, 15, 10} leader(arr) } func leader(arr []int) { for i := 0; i < len(arr); i++ { flag := false for j := i + 1; j < len(arr); j++ { if arr[i] <= arr[j] { flag = true break } } if !flag { fmt.Printf(\"%d \", arr[i]) } } fmt.Println() } Time Complexity: O(n 2 )","title":"Naive Approach"},{"location":"array/leaders_in_array.html#efficient-approach","text":"package main import ( \"fmt\" ) func main() { arr := []int{17, 20, 14, 13, 16, 15, 12} // 12 15 16 20 // arr := []int{10, 20, 30} // 30 // arr := []int{25, 15, 10} // 10 15 25 leader(arr) } func leader(arr []int) { curLeader := arr[len(arr)-1] fmt.Printf(\"%d \", curLeader) for i := len(arr) - 2; i >= 0; i-- { if curLeader < arr[i] { curLeader = arr[i] fmt.Printf(\"%d \", curLeader) } } fmt.Println() } Time Complexity: \u03b8(n) Note: It will print leaders in reverse order If we want to print in same order as we have in array, then we can store leaders in a new array and then we can iterate new array in reverse order and print each element.","title":"Efficient Approach"},{"location":"array/left_rotate_array_by_d.html","text":"Left Rotate Array by d Input: arr[] = {11, 22, 33, 44, 55} d = 2 Output: arr[] = {33, 44, 55, 11, 22} Input: arr[] = {11, 15, 33, 19} d = 3 Output: arr[] = {19, 11, 15, 33} We may assume that d <= No of elements in array If d > no of elements in array then we can simply d = d-n Naive Approach package main import ( \"fmt\" ) func main() { // arr := []int{11, 22, 33, 44, 55} // [33 44 55 11 22] // leftRotate(arr, 2) // fmt.Println(arr) arr := []int{11, 15, 33, 19} // [19 11 15 33] leftRotate(arr, 3) fmt.Println(arr) } func leftRotate(arr []int, d int) { for i := 0; i < d; i++ { leftRotateOne(arr) } } func leftRotateOne(arr []int) { temp := arr[0] for i := 1; i < len(arr); i++ { arr[i-1] = arr[i] } arr[len(arr)-1] = temp } Time Complexity: \u03b8(n * d) Aux Space: \u03b8(1) Better Approach package main import ( \"fmt\" ) func main() { arr := []int{11, 22, 33, 44, 55} // [33 44 55 11 22] leftRotate(arr, 2) fmt.Println(arr) // arr := []int{11, 15, 33, 19} // [19 11 15 33] // leftRotate(arr, 3) // fmt.Println(arr) } func leftRotate(arr []int, d int) { var temp []int for i := 0; i < d; i++ { temp = append(temp, arr[i]) } for i := d; i < len(arr); i++ { arr[i-d] = arr[i] } for i := range temp { arr[len(arr)-d+i] = temp[i] } } Time Complexity: \u03b8(d+ (n-d) + d) = \u03b8(n+d) = \u03b8(n) d is smaller than n so ignore d Aux Space: \u03b8(d) Best Approach package main import ( \"fmt\" ) func main() { // arr := []int{11, 22, 33, 44, 55} // [33 44 55 11 22] // leftRotate(arr, 2) // fmt.Println(arr) arr := []int{11, 15, 33, 19} // [19 11 15 33] leftRotate(arr, 3) fmt.Println(arr) } func reverve(arr []int, low, high int) { for low < high { temp := arr[low] arr[low] = arr[high] arr[high] = temp low++ high-- } } func leftRotate(arr []int, d int) { reverve(arr, 0, d-1) reverve(arr, d, len(arr)-1) reverve(arr, 0, len(arr)-1) } Time Complexity: \u03b8(d + (n-d) + n) = \u03b8(2n) = \u03b8(n) Aux Space: \u03b8(1)","title":"Left Rotate Array by d"},{"location":"array/left_rotate_array_by_d.html#left-rotate-array-by-d","text":"Input: arr[] = {11, 22, 33, 44, 55} d = 2 Output: arr[] = {33, 44, 55, 11, 22} Input: arr[] = {11, 15, 33, 19} d = 3 Output: arr[] = {19, 11, 15, 33} We may assume that d <= No of elements in array If d > no of elements in array then we can simply d = d-n","title":"Left Rotate Array by d"},{"location":"array/left_rotate_array_by_d.html#naive-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{11, 22, 33, 44, 55} // [33 44 55 11 22] // leftRotate(arr, 2) // fmt.Println(arr) arr := []int{11, 15, 33, 19} // [19 11 15 33] leftRotate(arr, 3) fmt.Println(arr) } func leftRotate(arr []int, d int) { for i := 0; i < d; i++ { leftRotateOne(arr) } } func leftRotateOne(arr []int) { temp := arr[0] for i := 1; i < len(arr); i++ { arr[i-1] = arr[i] } arr[len(arr)-1] = temp } Time Complexity: \u03b8(n * d) Aux Space: \u03b8(1)","title":"Naive Approach"},{"location":"array/left_rotate_array_by_d.html#better-approach","text":"package main import ( \"fmt\" ) func main() { arr := []int{11, 22, 33, 44, 55} // [33 44 55 11 22] leftRotate(arr, 2) fmt.Println(arr) // arr := []int{11, 15, 33, 19} // [19 11 15 33] // leftRotate(arr, 3) // fmt.Println(arr) } func leftRotate(arr []int, d int) { var temp []int for i := 0; i < d; i++ { temp = append(temp, arr[i]) } for i := d; i < len(arr); i++ { arr[i-d] = arr[i] } for i := range temp { arr[len(arr)-d+i] = temp[i] } } Time Complexity: \u03b8(d+ (n-d) + d) = \u03b8(n+d) = \u03b8(n) d is smaller than n so ignore d Aux Space: \u03b8(d)","title":"Better Approach"},{"location":"array/left_rotate_array_by_d.html#best-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{11, 22, 33, 44, 55} // [33 44 55 11 22] // leftRotate(arr, 2) // fmt.Println(arr) arr := []int{11, 15, 33, 19} // [19 11 15 33] leftRotate(arr, 3) fmt.Println(arr) } func reverve(arr []int, low, high int) { for low < high { temp := arr[low] arr[low] = arr[high] arr[high] = temp low++ high-- } } func leftRotate(arr []int, d int) { reverve(arr, 0, d-1) reverve(arr, d, len(arr)-1) reverve(arr, 0, len(arr)-1) } Time Complexity: \u03b8(d + (n-d) + n) = \u03b8(2n) = \u03b8(n) Aux Space: \u03b8(1)","title":"Best Approach"},{"location":"array/left_rotate_array_by_one.html","text":"Left Rotate an Array by One Input: arr[] = {11, 22, 33, 44, 55} Output: arr[] = {22, 33, 44, 55, 11} Input: arr[] = {50, 3, 22} Output: arr[] = {3, 22, 50} package main import ( \"fmt\" ) func main() { // arr := []int{11, 22, 33, 44, 55} // [22 33 44 55 11] arr := []int{50, 3, 22} // [3 22 50] leftRotateOne(arr) fmt.Println(arr) } func leftRotateOne(arr []int) { temp := arr[0] for i := 1; i < len(arr); i++ { arr[i-1] = arr[i] } arr[len(arr)-1] = temp } Time Complexity: \u03b8(n) Space Complexity: \u03b8(1)","title":"Left Rotate Array by One"},{"location":"array/left_rotate_array_by_one.html#left-rotate-an-array-by-one","text":"Input: arr[] = {11, 22, 33, 44, 55} Output: arr[] = {22, 33, 44, 55, 11} Input: arr[] = {50, 3, 22} Output: arr[] = {3, 22, 50} package main import ( \"fmt\" ) func main() { // arr := []int{11, 22, 33, 44, 55} // [22 33 44 55 11] arr := []int{50, 3, 22} // [3 22 50] leftRotateOne(arr) fmt.Println(arr) } func leftRotateOne(arr []int) { temp := arr[0] for i := 1; i < len(arr); i++ { arr[i-1] = arr[i] } arr[len(arr)-1] = temp } Time Complexity: \u03b8(n) Space Complexity: \u03b8(1)","title":"Left Rotate an Array by One"},{"location":"array/maximum_difference.html","text":"Maximum Differences Maximum value of a[j] > a[i] such that j>i Input: arr[] = {3, 4, 11, 7, 5, 9, 1} Outout: 8 Input: arr[] = {8, 10, 6, 7, 4, 2} Outout: 2 Input: arr[] = {20, 30, 40} Output: 20 Here array is sorted so max diff is last element minus first element. Input: arr[] = {40, 30, 6, 4} Output: -2 Here array is reverse sorted then output will be negative Naive Approach package main import ( \"fmt\" ) func main() { arr := []int{3, 4, 11, 7, 5, 9, 1} // 8 // arr := []int{8, 10, 6, 7, 4, 2} // 2 // arr := []int{20, 30, 40} // 20 // arr := []int{40, 30, 6, 4} // -2 result := maxDiff(arr) fmt.Println(result) } func maxDiff(arr []int) int { result := arr[1] - arr[0] for i := 0; i < len(arr); i++ { for j := i + 1; j < len(arr); j++ { result = max(result, arr[j]-arr[i]) } } return result } func max(a, b int) int { if a > b { return a } return b } Time complexity: \u03b8(n 2 ) Efficient Approach package main import ( \"fmt\" ) func main() { arr := []int{3, 4, 11, 7, 5, 9, 1} // 8 // arr := []int{8, 10, 6, 7, 4, 2} // 2 // arr := []int{20, 30, 40} // 20 // arr := []int{40, 30, 6, 4} // -2 result := maxDiff(arr) fmt.Println(result) } func maxDiff(arr []int) int { result := arr[1] - arr[0] minVal := arr[0] for i := 1; i < len(arr); i++ { result = max(result, arr[i]-minVal) minVal = min(minVal, arr[i]) } return result } func max(a, b int) int { if a > b { return a } return b } func min(a, b int) int { if a < b { return a } return b } Time Complexity: \u03b8(n) Aux Space: \u03b8(1)","title":"Maximum Difference"},{"location":"array/maximum_difference.html#maximum-differences","text":"Maximum value of a[j] > a[i] such that j>i Input: arr[] = {3, 4, 11, 7, 5, 9, 1} Outout: 8 Input: arr[] = {8, 10, 6, 7, 4, 2} Outout: 2 Input: arr[] = {20, 30, 40} Output: 20 Here array is sorted so max diff is last element minus first element. Input: arr[] = {40, 30, 6, 4} Output: -2 Here array is reverse sorted then output will be negative","title":"Maximum Differences"},{"location":"array/maximum_difference.html#naive-approach","text":"package main import ( \"fmt\" ) func main() { arr := []int{3, 4, 11, 7, 5, 9, 1} // 8 // arr := []int{8, 10, 6, 7, 4, 2} // 2 // arr := []int{20, 30, 40} // 20 // arr := []int{40, 30, 6, 4} // -2 result := maxDiff(arr) fmt.Println(result) } func maxDiff(arr []int) int { result := arr[1] - arr[0] for i := 0; i < len(arr); i++ { for j := i + 1; j < len(arr); j++ { result = max(result, arr[j]-arr[i]) } } return result } func max(a, b int) int { if a > b { return a } return b } Time complexity: \u03b8(n 2 )","title":"Naive Approach"},{"location":"array/maximum_difference.html#efficient-approach","text":"package main import ( \"fmt\" ) func main() { arr := []int{3, 4, 11, 7, 5, 9, 1} // 8 // arr := []int{8, 10, 6, 7, 4, 2} // 2 // arr := []int{20, 30, 40} // 20 // arr := []int{40, 30, 6, 4} // -2 result := maxDiff(arr) fmt.Println(result) } func maxDiff(arr []int) int { result := arr[1] - arr[0] minVal := arr[0] for i := 1; i < len(arr); i++ { result = max(result, arr[i]-minVal) minVal = min(minVal, arr[i]) } return result } func max(a, b int) int { if a > b { return a } return b } func min(a, b int) int { if a < b { return a } return b } Time Complexity: \u03b8(n) Aux Space: \u03b8(1)","title":"Efficient Approach"},{"location":"array/move_all_zeroes_to_end.html","text":"Move All Zeroes to End Input: arr[] = {18, 13, 0, 30, 0, 40} Output: arr[] = {18, 13, 30, 40, 0, 0} Input: arr[] = {0, 0, 0, 20, 0} Output: arr[] = {20, 0, 0, 0} Input: arr[] = {50, 66} Output: arr[] = {50, 66} Noive Approach package main import ( \"fmt\" ) func main() { // arr := []int{18, 13, 0, 30, 0, 40} // [18 13 40 30 0 0] // arr := []int{0, 0, 0, 20, 0} // [20 0 0 0 0] arr := []int{50, 66} // [50 66] moveToEnd(arr) fmt.Println(arr) } func moveToEnd(arr []int) { for i := 0; i < len(arr); i++ { if arr[i] == 0 { for j := i + 1; j < len(arr); j++ { if arr[j] != 0 { arr[i], arr[j] = swap(arr[i], arr[j]) } } } } } func swap(a, b int) (int, int) { return b, a } Time Complexity: O(n*n) Efficient Approach package main import ( \"fmt\" ) func main() { // arr := []int{18, 13, 0, 30, 0, 40} // [18 13 40 30 0 0] // arr := []int{0, 0, 0, 20, 0} // [20 0 0 0 0] arr := []int{50, 66} // [50 66] moveToEnd(arr) fmt.Println(arr) } func moveToEnd(arr []int) { count := 0 for i := 0; i < len(arr); i++ { if arr[i] != 0 { arr[i], arr[count] = swap(arr[i], arr[count]) count++ } } } func swap(a, b int) (int, int) { return b, a } Time Complexity: O(n)","title":"Move All Zeroes to End"},{"location":"array/move_all_zeroes_to_end.html#move-all-zeroes-to-end","text":"Input: arr[] = {18, 13, 0, 30, 0, 40} Output: arr[] = {18, 13, 30, 40, 0, 0} Input: arr[] = {0, 0, 0, 20, 0} Output: arr[] = {20, 0, 0, 0} Input: arr[] = {50, 66} Output: arr[] = {50, 66}","title":"Move All Zeroes to End"},{"location":"array/move_all_zeroes_to_end.html#noive-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{18, 13, 0, 30, 0, 40} // [18 13 40 30 0 0] // arr := []int{0, 0, 0, 20, 0} // [20 0 0 0 0] arr := []int{50, 66} // [50 66] moveToEnd(arr) fmt.Println(arr) } func moveToEnd(arr []int) { for i := 0; i < len(arr); i++ { if arr[i] == 0 { for j := i + 1; j < len(arr); j++ { if arr[j] != 0 { arr[i], arr[j] = swap(arr[i], arr[j]) } } } } } func swap(a, b int) (int, int) { return b, a } Time Complexity: O(n*n)","title":"Noive Approach"},{"location":"array/move_all_zeroes_to_end.html#efficient-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{18, 13, 0, 30, 0, 40} // [18 13 40 30 0 0] // arr := []int{0, 0, 0, 20, 0} // [20 0 0 0 0] arr := []int{50, 66} // [50 66] moveToEnd(arr) fmt.Println(arr) } func moveToEnd(arr []int) { count := 0 for i := 0; i < len(arr); i++ { if arr[i] != 0 { arr[i], arr[count] = swap(arr[i], arr[count]) count++ } } } func swap(a, b int) (int, int) { return b, a } Time Complexity: O(n)","title":"Efficient Approach"},{"location":"array/operations.html","text":"Operations Search (unsorted array) package main import \"fmt\" func main() { arr := []int{10, 3, 6, 14, 17} result := search(arr, 14) if result == -1 { fmt.Println(\"Element not found\") } else { fmt.Println(\"Element found at index:\", result) } } func search(arr []int, ele int) int { for i := 0; i < len(arr); i++ { if arr[i] == ele { return i } } return -1 } Time Complexity: O(n)","title":"Operation in Array"},{"location":"array/operations.html#operations","text":"","title":"Operations"},{"location":"array/operations.html#search-unsorted-array","text":"package main import \"fmt\" func main() { arr := []int{10, 3, 6, 14, 17} result := search(arr, 14) if result == -1 { fmt.Println(\"Element not found\") } else { fmt.Println(\"Element found at index:\", result) } } func search(arr []int, ele int) int { for i := 0; i < len(arr); i++ { if arr[i] == ele { return i } } return -1 } Time Complexity: O(n)","title":"Search (unsorted array)"},{"location":"array/remove_duplicates_from_sorted_array.html","text":"Remove Duplicates from Sorted Array Input: arr[] = {12, 15, 15, 20, 20, 20, 20} length: 7 Output: arr[] = {12, 15, 20} length: 3 Input: arr[] = {16, 16, 16} length: 3 Output: arr[] = {16} length: 1 Naive Approach package main import ( \"fmt\" ) func main() { // arr := []int{12, 15, 15, 20, 20, 20, 20} // [12 15 20] arr := []int{16, 16, 16} // [16] result := removeDups(arr) fmt.Println(\"arr[] =\", result) fmt.Println(\"length =\", len(result)) } func removeDups(arr []int) []int { var temp []int temp = append(temp, arr[0]) result := 1 for i := 1; i < len(arr); i++ { if temp[result-1] != arr[i] { temp = append(temp, arr[i]) result++ } } for i := 0; i < result; i++ { arr[i] = temp[i] } return arr[:result] } Time Complexity: O(n) Space Complexity: O(n) Efficient Approach package main import ( \"fmt\" ) func main() { // arr := []int{12, 15, 15, 20, 20, 20, 20} // [12 15 20] arr := []int{16, 16, 16} // [16] result := removeDups(arr) fmt.Println(\"arr[] =\", result) fmt.Println(\"length =\", len(result)) } func removeDups(arr []int) []int { result := 1 for i := 1; i < len(arr); i++ { if arr[i] != arr[result-1] { arr[result] = arr[i] result++ } } return arr[:result] } Time Complexity: O(n) Space Complexity: O(1) Note: we are using result variable to keep track to unique elements in array.","title":"Remove Duplicate from Sorted Array"},{"location":"array/remove_duplicates_from_sorted_array.html#remove-duplicates-from-sorted-array","text":"Input: arr[] = {12, 15, 15, 20, 20, 20, 20} length: 7 Output: arr[] = {12, 15, 20} length: 3 Input: arr[] = {16, 16, 16} length: 3 Output: arr[] = {16} length: 1","title":"Remove Duplicates from Sorted Array"},{"location":"array/remove_duplicates_from_sorted_array.html#naive-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{12, 15, 15, 20, 20, 20, 20} // [12 15 20] arr := []int{16, 16, 16} // [16] result := removeDups(arr) fmt.Println(\"arr[] =\", result) fmt.Println(\"length =\", len(result)) } func removeDups(arr []int) []int { var temp []int temp = append(temp, arr[0]) result := 1 for i := 1; i < len(arr); i++ { if temp[result-1] != arr[i] { temp = append(temp, arr[i]) result++ } } for i := 0; i < result; i++ { arr[i] = temp[i] } return arr[:result] } Time Complexity: O(n) Space Complexity: O(n)","title":"Naive Approach"},{"location":"array/remove_duplicates_from_sorted_array.html#efficient-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{12, 15, 15, 20, 20, 20, 20} // [12 15 20] arr := []int{16, 16, 16} // [16] result := removeDups(arr) fmt.Println(\"arr[] =\", result) fmt.Println(\"length =\", len(result)) } func removeDups(arr []int) []int { result := 1 for i := 1; i < len(arr); i++ { if arr[i] != arr[result-1] { arr[result] = arr[i] result++ } } return arr[:result] } Time Complexity: O(n) Space Complexity: O(1) Note: we are using result variable to keep track to unique elements in array.","title":"Efficient Approach"},{"location":"array/remove_duplicates_from_unsorted_array.html","text":"Remove Duplicates from Un-sorted Array Implementation package main import \"fmt\" func main() { arr := []int{10, 12, 8, 10, 12} result := removeDups(arr) fmt.Println(result) } func removeDups(arr []int) []int { var tempArr []int m := make(map[int]bool) for _, ele := range arr { if _, ok := m[ele]; !ok { m[ele] = true tempArr = append(tempArr, ele) } } return tempArr }","title":"Remove Duplicate from Unsorted Array"},{"location":"array/remove_duplicates_from_unsorted_array.html#remove-duplicates-from-un-sorted-array","text":"","title":"Remove Duplicates from Un-sorted Array"},{"location":"array/remove_duplicates_from_unsorted_array.html#implementation","text":"package main import \"fmt\" func main() { arr := []int{10, 12, 8, 10, 12} result := removeDups(arr) fmt.Println(result) } func removeDups(arr []int) []int { var tempArr []int m := make(map[int]bool) for _, ele := range arr { if _, ok := m[ele]; !ok { m[ele] = true tempArr = append(tempArr, ele) } } return tempArr }","title":"Implementation"},{"location":"array/reverse_array.html","text":"Reverse an Array Input: arr[] = {12, 7, 9, 33} Output arr[] = {33, 9, 7, 12} Input: arr[] = {33, 22, 9, 3, 99} Output: arr[] = {99, 3, 9, 22, 33} Approach One package main import ( \"fmt\" ) func main() { arr := []int{12, 7, 9, 33} // [33 9 7 12] // arr := []int{33, 22, 9, 3, 99} // [99 3 9 22 33 reserveArray(arr) fmt.Println(arr) } func reserveArray(arr []int) { low := 0 high := len(arr) - 1 for low < high { temp := arr[low] arr[low] = arr[high] arr[high] = temp low++ high-- } } Time Complexity: : \u03b8(n) Aux Space: \u03b8(1) Approach Two package main import ( \"fmt\" ) func main() { // arr := []int{12, 7, 9, 33} // [33 9 7 12] arr := []int{33, 22, 9, 3, 99} // [99 3 9 22 33 reverseArray(arr) fmt.Println(arr) } func reverseArray(arr []int) { for i := 0; i < len(arr)/2; i++ { temp := arr[i] j := len(arr) - i - 1 arr[i] = arr[j] arr[j] = temp } } Time Complexity: : \u03b8(n) Aux Space: \u03b8(1)","title":"Reverse an Array"},{"location":"array/reverse_array.html#reverse-an-array","text":"Input: arr[] = {12, 7, 9, 33} Output arr[] = {33, 9, 7, 12} Input: arr[] = {33, 22, 9, 3, 99} Output: arr[] = {99, 3, 9, 22, 33}","title":"Reverse an Array"},{"location":"array/reverse_array.html#approach-one","text":"package main import ( \"fmt\" ) func main() { arr := []int{12, 7, 9, 33} // [33 9 7 12] // arr := []int{33, 22, 9, 3, 99} // [99 3 9 22 33 reserveArray(arr) fmt.Println(arr) } func reserveArray(arr []int) { low := 0 high := len(arr) - 1 for low < high { temp := arr[low] arr[low] = arr[high] arr[high] = temp low++ high-- } } Time Complexity: : \u03b8(n) Aux Space: \u03b8(1)","title":"Approach One"},{"location":"array/reverse_array.html#approach-two","text":"package main import ( \"fmt\" ) func main() { // arr := []int{12, 7, 9, 33} // [33 9 7 12] arr := []int{33, 22, 9, 3, 99} // [99 3 9 22 33 reverseArray(arr) fmt.Println(arr) } func reverseArray(arr []int) { for i := 0; i < len(arr)/2; i++ { temp := arr[i] j := len(arr) - i - 1 arr[i] = arr[j] arr[j] = temp } } Time Complexity: : \u03b8(n) Aux Space: \u03b8(1)","title":"Approach Two"},{"location":"array/second_largest_element.html","text":"Second Largest Element in Array Input: arr[] = {10, 5, 6, 15} Output: 0 // index of 10 Input: arr[] = {30, 15, 23, 9, 28} Output: 4 // index of 28 Inpute: arr[] = {15, 15, 15} Output: -1 // No second element Naive Approach package main import ( \"fmt\" ) func main() { // arr := []int{10, 5, 6, 15} // arr := []int{30, 15, 23, 9, 28} arr := []int{15, 15, 15} secLargest := getSecondLargest(arr) if secLargest == -1 { fmt.Println(\"No sencond largest found\") } else { fmt.Println(\"largest element at index\", secLargest) fmt.Println(\"largest element\", arr[secLargest]) } } func getLargest(arr []int) int { largest := 0 for i := 1; i < len(arr); i++ { if arr[i] > arr[largest] { largest = i } } return largest } func getSecondLargest(arr []int) int { first := getLargest(arr) second := -1 for i := 0; i < len(arr); i++ { if arr[first] != arr[i] { if second == -1 { second = i } else if arr[second] < arr[i] { second = i } } } return second } Efficient Approach arr[i] > arr[largest]: res = largest, largest = i arr[i] == arr[largest]: Ignore arr[i] < arr[largest]: res == -1: res = i arr[i] <= arr[res]: Ignore arr[i] > arr[res]: res = i package main import ( \"fmt\" ) func main() { arr := []int{10, 5, 6, 15} // arr := []int{30, 15, 23, 9, 28} // arr := []int{15, 15, 15} secLargest := getSecondLargest(arr) if secLargest == -1 { fmt.Println(\"No sencond largest found\") } else { fmt.Println(\"largest element at index\", secLargest) fmt.Println(\"largest element\", arr[secLargest]) } } func getSecondLargest(arr []int) int { first := 0 second := -1 for i := 1; i < len(arr); i++ { if arr[i] > arr[first] { second = first first = i } else if (second == -1 || arr[i] > arr[second]) && arr[i] != arr[first] { second = i } } return second } Time Complexity: O(n)","title":"Second Largest Element in Array"},{"location":"array/second_largest_element.html#second-largest-element-in-array","text":"Input: arr[] = {10, 5, 6, 15} Output: 0 // index of 10 Input: arr[] = {30, 15, 23, 9, 28} Output: 4 // index of 28 Inpute: arr[] = {15, 15, 15} Output: -1 // No second element","title":"Second Largest Element in Array"},{"location":"array/second_largest_element.html#naive-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{10, 5, 6, 15} // arr := []int{30, 15, 23, 9, 28} arr := []int{15, 15, 15} secLargest := getSecondLargest(arr) if secLargest == -1 { fmt.Println(\"No sencond largest found\") } else { fmt.Println(\"largest element at index\", secLargest) fmt.Println(\"largest element\", arr[secLargest]) } } func getLargest(arr []int) int { largest := 0 for i := 1; i < len(arr); i++ { if arr[i] > arr[largest] { largest = i } } return largest } func getSecondLargest(arr []int) int { first := getLargest(arr) second := -1 for i := 0; i < len(arr); i++ { if arr[first] != arr[i] { if second == -1 { second = i } else if arr[second] < arr[i] { second = i } } } return second }","title":"Naive Approach"},{"location":"array/second_largest_element.html#efficient-approach","text":"arr[i] > arr[largest]: res = largest, largest = i arr[i] == arr[largest]: Ignore arr[i] < arr[largest]: res == -1: res = i arr[i] <= arr[res]: Ignore arr[i] > arr[res]: res = i package main import ( \"fmt\" ) func main() { arr := []int{10, 5, 6, 15} // arr := []int{30, 15, 23, 9, 28} // arr := []int{15, 15, 15} secLargest := getSecondLargest(arr) if secLargest == -1 { fmt.Println(\"No sencond largest found\") } else { fmt.Println(\"largest element at index\", secLargest) fmt.Println(\"largest element\", arr[secLargest]) } } func getSecondLargest(arr []int) int { first := 0 second := -1 for i := 1; i < len(arr); i++ { if arr[i] > arr[first] { second = first first = i } else if (second == -1 || arr[i] > arr[second]) && arr[i] != arr[first] { second = i } } return second } Time Complexity: O(n)","title":"Efficient Approach"},{"location":"array/sum_of_all_pair_in_sorted_array_is_equal_to_given_number.html","text":"Sum of All Pair in Sorted Array is Equal to Given Number Input arr := []int{1, 2, 3, 4, 5} sum:= 7 Output: [2 5] [3 4] Implementation package main import \"fmt\" func main() { arr := []int{1, 2, 3, 4, 5} result := getSumPairs(arr, 7) fmt.Println(result) } func getSumPairs(arr []int, sum int) [][2]int { i := 0 j := len(arr) - 1 result := make([][2]int, 0) for i < j { var pair [2]int addition := arr[i] + arr[j] if addition == sum { pair[0] = arr[i] pair[1] = arr[j] result = append(result, pair) i++ j-- } else if addition < sum { i++ } else { j-- } } return result }","title":"Sum of All Pair in Sorted Array is Equal to Given Number"},{"location":"array/sum_of_all_pair_in_sorted_array_is_equal_to_given_number.html#sum-of-all-pair-in-sorted-array-is-equal-to-given-number","text":"Input arr := []int{1, 2, 3, 4, 5} sum:= 7 Output: [2 5] [3 4]","title":"Sum of All Pair in Sorted Array is Equal to Given Number"},{"location":"array/sum_of_all_pair_in_sorted_array_is_equal_to_given_number.html#implementation","text":"package main import \"fmt\" func main() { arr := []int{1, 2, 3, 4, 5} result := getSumPairs(arr, 7) fmt.Println(result) } func getSumPairs(arr []int, sum int) [][2]int { i := 0 j := len(arr) - 1 result := make([][2]int, 0) for i < j { var pair [2]int addition := arr[i] + arr[j] if addition == sum { pair[0] = arr[i] pair[1] = arr[j] result = append(result, pair) i++ j-- } else if addition < sum { i++ } else { j-- } } return result }","title":"Implementation"},{"location":"array/union_of_two_sorted_array.html","text":"Union if Two Sorted Array Input: a[] = {13, 15, 18} b[] = {12, 18, 19, 20, 25} Output: c[] = {12, 13, 15, 18, 19, 20, 25} Input: a[] = {12, 13, 13, 13, 14, 14} b[] = {14, 14} Output: c[] = {12, 13, 14} Naive Approach package main import ( \"fmt\" \"sort\" ) func main() { a := []int{3, 5, 10, 10, 10, 15, 15, 20} b := []int{5, 10, 10, 15, 30} res := union(a, b) fmt.Println(res) //[3 5 10 15 20 30] } func union(a, b []int) (res []int) { c := make([]int, len(a)+len(b)) for i := 0; i < len(a); i++ { c[i] = a[i] } m := len(a) for j := 0; j < len(b); j++ { c[m+j] = b[j] } sort.Ints(c) for i := 0; i < len(c); i++ { if i == 0 || c[i] != c[i-1] { res = append(res, c[i]) } } return res } Time Complexity: O((m+n)*log(m+n)) Dry Run: a[] = {3, 5, 5} b[] = {1, 5, 7, 7} After 1st loop: c[] = {3, 5, 5, , , , } After 2nd loop: c[] = {3, 5, 5, 1, 5, 7, 7} After sorting: c[] = {1, 3, 5, 5, 5, 7, 7} 3rd loop: res[] = {1, 3, 5, 7} Efficient Solution Implementation Idea if i > 0 && a[i] == a[i-1] { i++; continue; } if j > 0 && b[j] == b[j-1] { j++; continue; } if a[i] < b[j] { c=append(c,a[i]); i++ } if a[i] > b[j] { c=append(c,b[j]); j++ } if a[i] == b[j] { c=append(c,a[i]); i++; j++ } Implementation package main import ( \"fmt\" ) func main() { a := []int{3, 5, 10, 10, 10, 15, 15, 20} b := []int{5, 10, 10, 15, 30} res := union(a, b) fmt.Println(res) //[3 5 10 15 20 30] } func union(a, b []int) (res []int) { m := len(a) n := len(b) i, j := 0, 0 for i < m && j < n { if i > 0 && a[i] == a[i-1] { i++ continue } if j > 0 && b[j] == b[j-1] { j++ continue } if a[i] < b[j] { res = append(res, a[i]) i++ } else if a[i] > b[j] { res = append(res, b[j]) j++ } else { res = append(res, a[i]) i++ j++ } } for i < m { if i == 0 || a[i] != a[i-1] { res = append(res, a[i]) } i++ } for j < n { if j == 0 || b[j] != b[j-1] { res = append(res, b[j]) } j++ } return } Dry Run a[] = {12, 20, 30, 30} b[] = {13, 30, 40} i=0; j=0; 1st Iteration: c[] = {12}, i=1 2nd Iteration: c[] = {12, 13}, j=1 3rd Iteration: c[] = {12, 13, 20}, i=2 4th Iteration: c[] = {12, 13, 20, 30}, i=3, j=2 5th Iteration: c[] = {12, 13, 20, 30}, i=4 Next Loop for(j < n) : c[] = {12, 13, 20, 30, 40}, j=3","title":"Union of Two Sorted Array"},{"location":"array/union_of_two_sorted_array.html#union-if-two-sorted-array","text":"Input: a[] = {13, 15, 18} b[] = {12, 18, 19, 20, 25} Output: c[] = {12, 13, 15, 18, 19, 20, 25} Input: a[] = {12, 13, 13, 13, 14, 14} b[] = {14, 14} Output: c[] = {12, 13, 14}","title":"Union if Two Sorted Array"},{"location":"array/union_of_two_sorted_array.html#naive-approach","text":"package main import ( \"fmt\" \"sort\" ) func main() { a := []int{3, 5, 10, 10, 10, 15, 15, 20} b := []int{5, 10, 10, 15, 30} res := union(a, b) fmt.Println(res) //[3 5 10 15 20 30] } func union(a, b []int) (res []int) { c := make([]int, len(a)+len(b)) for i := 0; i < len(a); i++ { c[i] = a[i] } m := len(a) for j := 0; j < len(b); j++ { c[m+j] = b[j] } sort.Ints(c) for i := 0; i < len(c); i++ { if i == 0 || c[i] != c[i-1] { res = append(res, c[i]) } } return res } Time Complexity: O((m+n)*log(m+n)) Dry Run: a[] = {3, 5, 5} b[] = {1, 5, 7, 7} After 1st loop: c[] = {3, 5, 5, , , , } After 2nd loop: c[] = {3, 5, 5, 1, 5, 7, 7} After sorting: c[] = {1, 3, 5, 5, 5, 7, 7} 3rd loop: res[] = {1, 3, 5, 7}","title":"Naive Approach"},{"location":"array/union_of_two_sorted_array.html#efficient-solution","text":"","title":"Efficient Solution"},{"location":"array/union_of_two_sorted_array.html#implementation-idea","text":"if i > 0 && a[i] == a[i-1] { i++; continue; } if j > 0 && b[j] == b[j-1] { j++; continue; } if a[i] < b[j] { c=append(c,a[i]); i++ } if a[i] > b[j] { c=append(c,b[j]); j++ } if a[i] == b[j] { c=append(c,a[i]); i++; j++ }","title":"Implementation Idea"},{"location":"array/union_of_two_sorted_array.html#implementation","text":"package main import ( \"fmt\" ) func main() { a := []int{3, 5, 10, 10, 10, 15, 15, 20} b := []int{5, 10, 10, 15, 30} res := union(a, b) fmt.Println(res) //[3 5 10 15 20 30] } func union(a, b []int) (res []int) { m := len(a) n := len(b) i, j := 0, 0 for i < m && j < n { if i > 0 && a[i] == a[i-1] { i++ continue } if j > 0 && b[j] == b[j-1] { j++ continue } if a[i] < b[j] { res = append(res, a[i]) i++ } else if a[i] > b[j] { res = append(res, b[j]) j++ } else { res = append(res, a[i]) i++ j++ } } for i < m { if i == 0 || a[i] != a[i-1] { res = append(res, a[i]) } i++ } for j < n { if j == 0 || b[j] != b[j-1] { res = append(res, b[j]) } j++ } return } Dry Run a[] = {12, 20, 30, 30} b[] = {13, 30, 40} i=0; j=0; 1st Iteration: c[] = {12}, i=1 2nd Iteration: c[] = {12, 13}, j=1 3rd Iteration: c[] = {12, 13, 20}, i=2 4th Iteration: c[] = {12, 13, 20, 30}, i=3, j=2 5th Iteration: c[] = {12, 13, 20, 30}, i=4 Next Loop for(j < n) : c[] = {12, 13, 20, 30, 40}, j=3","title":"Implementation"},{"location":"bst/second_largest_number_from_given_number.html","text":"Second Largest Number from Given Number 45 / \\ 40 60 / \\ / \\ 20 42 50 70 In given above tree, if given number n as 70 then result should be 60 if given number n as 60 then result should be 45 if given number n as 43 then result should be 42 if given number n as 15 then result should be NOT FOUND Implementation package main import \"fmt\" type Tree struct { data int left *Tree right *Tree } func main() { root := &Tree{data: 45} root.left = &Tree{data: 40} root.left.left = &Tree{data: 20} root.left.right = &Tree{data: 42} root.right = &Tree{data: 60} root.right.left = &Tree{data: 50} root.right.right = &Tree{data: 70} result := secondLarge(root, 80) if result == nil { fmt.Println(\"Not Found\") } else { fmt.Println(*result) } } func secondLarge(root *Tree, n int) *int { if root == nil { return nil } var result *int if root.data < n { result = secondLarge(root.right, n) } else if root.data > n { result = secondLarge(root.left, n) } if result == nil || *result >= n { if root.data > n { return nil } return &root.data } return result }","title":"Second Largest Number from Given Number"},{"location":"bst/second_largest_number_from_given_number.html#second-largest-number-from-given-number","text":"45 / \\ 40 60 / \\ / \\ 20 42 50 70 In given above tree, if given number n as 70 then result should be 60 if given number n as 60 then result should be 45 if given number n as 43 then result should be 42 if given number n as 15 then result should be NOT FOUND","title":"Second Largest Number from Given Number"},{"location":"bst/second_largest_number_from_given_number.html#implementation","text":"package main import \"fmt\" type Tree struct { data int left *Tree right *Tree } func main() { root := &Tree{data: 45} root.left = &Tree{data: 40} root.left.left = &Tree{data: 20} root.left.right = &Tree{data: 42} root.right = &Tree{data: 60} root.right.left = &Tree{data: 50} root.right.right = &Tree{data: 70} result := secondLarge(root, 80) if result == nil { fmt.Println(\"Not Found\") } else { fmt.Println(*result) } } func secondLarge(root *Tree, n int) *int { if root == nil { return nil } var result *int if root.data < n { result = secondLarge(root.right, n) } else if root.data > n { result = secondLarge(root.left, n) } if result == nil || *result >= n { if root.data > n { return nil } return &root.data } return result }","title":"Implementation"},{"location":"concurrency/print_odd_even_sequentially.html","text":"Print Odd and Even Sequentially using Two Goroutine Using Two Channels package main import ( \"fmt\" \"sync\" ) func main() { n := 10 chOdd := make(chan bool) chEven := make(chan bool) var wg sync.WaitGroup wg.Add(2) go odd(n, chOdd, chEven, &wg) go even(n, chOdd, chEven, &wg) wg.Wait() } func odd(n int, chOdd chan bool, chEven chan bool, wg *sync.WaitGroup) { defer wg.Done() for i := 1; i <= n; i = i + 2 { fmt.Println(i) chEven <- true <-chOdd } } func even(n int, chOdd chan bool, chEven chan bool, wg *sync.WaitGroup) { defer wg.Done() for i := 2; i <= n; i = i + 2 { <-chEven fmt.Println(i) chOdd <- true } } Output: 1 2 3 4 5 6 7 8 9 10 Using One Channel package main import ( \"fmt\" \"sync\" ) func main() { c := make(chan int) var wg sync.WaitGroup wg.Add(2) go odd(c, &wg) go even(c, &wg) wg.Wait() } func even(c chan int, wg *sync.WaitGroup) { defer wg.Done() for i := 1; i <= 10; i++ { <-c if i%2 == 0 { fmt.Println(i) } } } func odd(c chan int, wg *sync.WaitGroup) { defer wg.Done() for i := 1; i <= 10; i++ { c <- 1 if i%2 == 1 { fmt.Println(i) } } }","title":"Print Odd and Even Sequentially using goroutine"},{"location":"concurrency/print_odd_even_sequentially.html#print-odd-and-even-sequentially-using-two-goroutine","text":"","title":"Print Odd and Even Sequentially using Two Goroutine"},{"location":"concurrency/print_odd_even_sequentially.html#using-two-channels","text":"package main import ( \"fmt\" \"sync\" ) func main() { n := 10 chOdd := make(chan bool) chEven := make(chan bool) var wg sync.WaitGroup wg.Add(2) go odd(n, chOdd, chEven, &wg) go even(n, chOdd, chEven, &wg) wg.Wait() } func odd(n int, chOdd chan bool, chEven chan bool, wg *sync.WaitGroup) { defer wg.Done() for i := 1; i <= n; i = i + 2 { fmt.Println(i) chEven <- true <-chOdd } } func even(n int, chOdd chan bool, chEven chan bool, wg *sync.WaitGroup) { defer wg.Done() for i := 2; i <= n; i = i + 2 { <-chEven fmt.Println(i) chOdd <- true } } Output: 1 2 3 4 5 6 7 8 9 10","title":"Using Two Channels"},{"location":"concurrency/print_odd_even_sequentially.html#using-one-channel","text":"package main import ( \"fmt\" \"sync\" ) func main() { c := make(chan int) var wg sync.WaitGroup wg.Add(2) go odd(c, &wg) go even(c, &wg) wg.Wait() } func even(c chan int, wg *sync.WaitGroup) { defer wg.Done() for i := 1; i <= 10; i++ { <-c if i%2 == 0 { fmt.Println(i) } } } func odd(c chan int, wg *sync.WaitGroup) { defer wg.Done() for i := 1; i <= 10; i++ { c <- 1 if i%2 == 1 { fmt.Println(i) } } }","title":"Using One Channel"},{"location":"linked_list/add_one_linked_list_digit.html","text":"Add One in Lisked List Digit Input: |1| -> |3| -> |9| -> |9| Digit is: 1399 1399 + 1 = 1400 Output: |1| -> |4| -> |0| -> |0| Input: |9| -> |9| -> |9| -> |9| Output: |1| -> |0| -> |0| -> |0| -> |0| Implementation package main import \"fmt\" func main() { head := initialize(19999) head = addOne(head) printResult(head) } func initialize(n int) (head *Node) { var arr []int for n > 0 { data := n % 10 arr = append(arr, data) n = n / 10 } var curr *Node for i := len(arr) - 1; i >= 0; i-- { if i == len(arr)-1 { curr = &Node{data: arr[i]} head = curr } else { curr.next = &Node{data: arr[i]} curr = curr.next } } return head } func printResult(head *Node) { for head != nil { fmt.Print(head.data) head = head.next } fmt.Println() } type Node struct { data int next *Node } func addOne(head *Node) *Node { var stack []*Node curr := head for curr != nil { stack = append(stack, curr) curr = curr.next } carry := 1 for i := len(stack) - 1; i >= 0; i-- { ele := stack[i] add := ele.data + carry ele.data = add % 10 carry = add / 10 } if carry > 0 { newHead := &Node{data: carry} newHead.next = head return newHead } return head }","title":"Add One in Lisked List Digit"},{"location":"linked_list/add_one_linked_list_digit.html#add-one-in-lisked-list-digit","text":"Input: |1| -> |3| -> |9| -> |9| Digit is: 1399 1399 + 1 = 1400 Output: |1| -> |4| -> |0| -> |0| Input: |9| -> |9| -> |9| -> |9| Output: |1| -> |0| -> |0| -> |0| -> |0|","title":"Add One in Lisked List Digit"},{"location":"linked_list/add_one_linked_list_digit.html#implementation","text":"package main import \"fmt\" func main() { head := initialize(19999) head = addOne(head) printResult(head) } func initialize(n int) (head *Node) { var arr []int for n > 0 { data := n % 10 arr = append(arr, data) n = n / 10 } var curr *Node for i := len(arr) - 1; i >= 0; i-- { if i == len(arr)-1 { curr = &Node{data: arr[i]} head = curr } else { curr.next = &Node{data: arr[i]} curr = curr.next } } return head } func printResult(head *Node) { for head != nil { fmt.Print(head.data) head = head.next } fmt.Println() } type Node struct { data int next *Node } func addOne(head *Node) *Node { var stack []*Node curr := head for curr != nil { stack = append(stack, curr) curr = curr.next } carry := 1 for i := len(stack) - 1; i >= 0; i-- { ele := stack[i] add := ele.data + carry ele.data = add % 10 carry = add / 10 } if carry > 0 { newHead := &Node{data: carry} newHead.next = head return newHead } return head }","title":"Implementation"},{"location":"linked_list/delete_middle_ele_linked_list.html","text":"Delete Middle Element of Singly Linked List Input: 1 -> 2 -> 3 -> 4 -> 5 Output: 1 -> 2 -> 4 -> 5 Note: If there are odd number of element then delete middle Input: 1 -> 2 -> 3 -> 4 Output: 1 -> 2 -> 4 Note: If there are even number of element then there will be two middle elements. So we will delete second middle. Implementation package main import \"fmt\" type Node struct { data int next *Node } func main() { head := &Node{data: 1} head.next = &Node{data: 2} head.next.next = &Node{data: 3} head.next.next.next = &Node{data: 4} head.next.next.next.next = &Node{data: 5} deleteMiddle(head) for head != nil { fmt.Printf(\"%d \", head.data) head = head.next } fmt.Println() } func deleteMiddle(head *Node) { fast := head slow := head pre := head for fast != nil && fast.next != nil { pre = slow slow = slow.next fast = fast.next.next } pre.next = slow.next }","title":"Delete Middle Element of Singly Linked List"},{"location":"linked_list/delete_middle_ele_linked_list.html#delete-middle-element-of-singly-linked-list","text":"Input: 1 -> 2 -> 3 -> 4 -> 5 Output: 1 -> 2 -> 4 -> 5 Note: If there are odd number of element then delete middle Input: 1 -> 2 -> 3 -> 4 Output: 1 -> 2 -> 4 Note: If there are even number of element then there will be two middle elements. So we will delete second middle.","title":"Delete Middle Element of Singly Linked List"},{"location":"linked_list/delete_middle_ele_linked_list.html#implementation","text":"package main import \"fmt\" type Node struct { data int next *Node } func main() { head := &Node{data: 1} head.next = &Node{data: 2} head.next.next = &Node{data: 3} head.next.next.next = &Node{data: 4} head.next.next.next.next = &Node{data: 5} deleteMiddle(head) for head != nil { fmt.Printf(\"%d \", head.data) head = head.next } fmt.Println() } func deleteMiddle(head *Node) { fast := head slow := head pre := head for fast != nil && fast.next != nil { pre = slow slow = slow.next fast = fast.next.next } pre.next = slow.next }","title":"Implementation"},{"location":"linked_list/reserve_singly_linked_list.html","text":"Reverse a Singly Linked List Input: 1 -> 2 -> 3 -> 4-> 5 OutPut: 5 -> 4 -> 3 -> 2 -> 1 Implementation package main import \"fmt\" type Node struct { data int next *Node } func main() { head := &Node{data: 1} head.next = &Node{data: 2} head.next.next = &Node{data: 3} head.next.next.next = &Node{data: 4} head.next.next.next.next = &Node{data: 5} head = reverse(head) for head != nil { fmt.Printf(\"%d \", head.data) head = head.next } fmt.Println() } func reverse(head *Node) *Node { curr := head var temp *Node = nil var pre *Node = nil for curr != nil { temp = curr.next curr.next = pre pre = curr curr = temp } return pre }","title":"Reverse A Singly Linked List"},{"location":"linked_list/reserve_singly_linked_list.html#reverse-a-singly-linked-list","text":"Input: 1 -> 2 -> 3 -> 4-> 5 OutPut: 5 -> 4 -> 3 -> 2 -> 1","title":"Reverse a Singly Linked List"},{"location":"linked_list/reserve_singly_linked_list.html#implementation","text":"package main import \"fmt\" type Node struct { data int next *Node } func main() { head := &Node{data: 1} head.next = &Node{data: 2} head.next.next = &Node{data: 3} head.next.next.next = &Node{data: 4} head.next.next.next.next = &Node{data: 5} head = reverse(head) for head != nil { fmt.Printf(\"%d \", head.data) head = head.next } fmt.Println() } func reverse(head *Node) *Node { curr := head var temp *Node = nil var pre *Node = nil for curr != nil { temp = curr.next curr.next = pre pre = curr curr = temp } return pre }","title":"Implementation"},{"location":"sorting/bubble_sort.html","text":"Bubble Sort Bubble sort is stable It is in-place Naive Approach package main import \"fmt\" func main() { arr := []int{10, 3, 25, 17, 21, 55} bubbleSort(arr) fmt.Println(arr) } func bubbleSort(arr []int) { for i := 0; i < len(arr); i++ { for j := 0; j < len(arr)-i-1; j++ { if arr[j] > arr[j+1] { arr[j], arr[j+1] = swap(arr[j], arr[j+1]) } } } } func swap(a, b int) (int, int) { return b, a } Time Complexity: \u03b8(n*n) Efficient Approach If array is already sorted or get sorted in middle of iteration. package main import \"fmt\" func main() { // arr := []int{10, 3, 25, 17, 21, 55} arr := []int{3, 10, 17, 21, 25, 55} bubbleSort(arr) fmt.Println(arr) } func bubbleSort(arr []int) { for i := 0; i < len(arr); i++ { swapped := false for j := 0; j < len(arr)-i-1; j++ { if arr[j] > arr[j+1] { arr[j], arr[j+1] = swap(arr[j], arr[j+1]) swapped = true } } if !swapped { break } } } func swap(a, b int) (int, int) { return b, a }","title":"Bubble Sort"},{"location":"sorting/bubble_sort.html#bubble-sort","text":"Bubble sort is stable It is in-place","title":"Bubble Sort"},{"location":"sorting/bubble_sort.html#naive-approach","text":"package main import \"fmt\" func main() { arr := []int{10, 3, 25, 17, 21, 55} bubbleSort(arr) fmt.Println(arr) } func bubbleSort(arr []int) { for i := 0; i < len(arr); i++ { for j := 0; j < len(arr)-i-1; j++ { if arr[j] > arr[j+1] { arr[j], arr[j+1] = swap(arr[j], arr[j+1]) } } } } func swap(a, b int) (int, int) { return b, a } Time Complexity: \u03b8(n*n)","title":"Naive Approach"},{"location":"sorting/bubble_sort.html#efficient-approach","text":"If array is already sorted or get sorted in middle of iteration. package main import \"fmt\" func main() { // arr := []int{10, 3, 25, 17, 21, 55} arr := []int{3, 10, 17, 21, 25, 55} bubbleSort(arr) fmt.Println(arr) } func bubbleSort(arr []int) { for i := 0; i < len(arr); i++ { swapped := false for j := 0; j < len(arr)-i-1; j++ { if arr[j] > arr[j+1] { arr[j], arr[j+1] = swap(arr[j], arr[j+1]) swapped = true } } if !swapped { break } } } func swap(a, b int) (int, int) { return b, a }","title":"Efficient Approach"},{"location":"sorting/insertion_sort.html","text":"Insertion Sort O(n 2 ) In-place and stable Used in practice for small array (Tim Sort and Intro Sort) O(n) in best case Note: It divides array into two sub array. 0 to i-1 is sorted and i to n-1 is unsorted. Since 0th element already sorted in 0-0 subarray, so we have started with i=1 package main import \"fmt\" func main() { arr := []int{10, 3, 25, 17, 21, 55} // arr := []int{3, 10, 17, 21, 25, 55} insertionSort(arr) fmt.Println(arr) } func insertionSort(arr []int) { for i := 1; i < len(arr); i++ { key := arr[i] j := i - 1 for j >= 0 && arr[j] > key { arr[j+1] = arr[j] j-- } arr[j+1] = key } } Time Complexity Best Case: \u03b8(n) if already sorted Worst Case: \u03b8(n 2 ) if it is reverse sorted In General: O(n 2 )","title":"Insertion Sort"},{"location":"sorting/insertion_sort.html#insertion-sort","text":"O(n 2 ) In-place and stable Used in practice for small array (Tim Sort and Intro Sort) O(n) in best case Note: It divides array into two sub array. 0 to i-1 is sorted and i to n-1 is unsorted. Since 0th element already sorted in 0-0 subarray, so we have started with i=1 package main import \"fmt\" func main() { arr := []int{10, 3, 25, 17, 21, 55} // arr := []int{3, 10, 17, 21, 25, 55} insertionSort(arr) fmt.Println(arr) } func insertionSort(arr []int) { for i := 1; i < len(arr); i++ { key := arr[i] j := i - 1 for j >= 0 && arr[j] > key { arr[j+1] = arr[j] j-- } arr[j+1] = key } } Time Complexity Best Case: \u03b8(n) if already sorted Worst Case: \u03b8(n 2 ) if it is reverse sorted In General: O(n 2 )","title":"Insertion Sort"},{"location":"sorting/introduction.html","text":"Introduction Stability of Sorting Algorithm A sorting algorithm is stable if it ensures the orignal order if 2 items has same value Example of stable sorts Bubble Sort Insertion Sort Merge Sort Example of unstable sorts Selection Sort Quick Sort Heap Sorts","title":"Introduction"},{"location":"sorting/introduction.html#introduction","text":"","title":"Introduction"},{"location":"sorting/introduction.html#stability-of-sorting-algorithm","text":"A sorting algorithm is stable if it ensures the orignal order if 2 items has same value Example of stable sorts Bubble Sort Insertion Sort Merge Sort Example of unstable sorts Selection Sort Quick Sort Heap Sorts","title":"Stability of Sorting Algorithm"},{"location":"sorting/merge_sort.html","text":"Merge Sort Introduction Divide and Conquer Algorithm Divide Conquer Merge Stable Algorithm \u03b8(n log n) time and O(n) aux space Well suited for linked list. Works in O(1) aux space Used in external sorting In generate for array. Quick sort outperforms it. Merge Two Sorted Array Input: a[] = {12, 17, 22} b[] = {7, 8, 8, 17} Ouput: c[] = {7, 8, 8, 12, 17, 22} Input: a[] = {11, 11, 22} b[] = {33} Ouput: c[] = {11, 11, 22, 33} Naive Solution package main import ( \"fmt\" \"sort\" ) type Person struct { id int name string } func main() { a := []int{10, 15, 20, 20} b := []int{1, 2, 13} c := merge(a, b) fmt.Println(c) } func merge(a []int, b []int) []int { c := make([]int, len(a)+len(b)) for i, ele := range a { c[i] = ele } for i, ele := range b { c[len(a)+i] = ele } sort.Ints(c) return c } Time Complexity: O((m+n) log(m+n)) Space Complexity: \u03b8(m+n) Dry Run: a[] = {10, 15, 20, 20} b[] = {1, 2, 13} After 1st Loop: c[] = {10, 15, 20, 20, , , _} After 2st Loop: c[] = {10, 15, 20, 20, 1, 2, 13} After Sorting: c[] = {1, 2, 10, 13, 15, 20, 20} Efficient Solution Initially i=0, j =0 if a[i] <= b[j] { append a[i]; i++} else append b[j]; j++ package main import \"fmt\" func main() { a := []int{5, 10, 15, 20} b := []int{10, 20, 30} res := merge(a, b) fmt.Println(res) } func merge(a []int, b []int) (result []int) { i := 0 j := 0 for i < len(a) && j < len(b) { if a[i] <= b[j] { result = append(result, a[i]) i++ } else { result = append(result, b[j]) j++ } } for i < len(a) { result = append(result, a[i]) i++ } for j < len(b) { result = append(result, b[j]) j++ } return } Time Complexity: \u03b8(m+n) Dry Run: a := {5, 10, 15, 20} b := {10, 20, 30} First Loop i=0, j=0 c[]={5} i=1 c[]={5, 10} i=2 c[]={5, 10, 10} j=1 c[]={5, 10, 10, 15} i=3 c[]={5, 10, 10, 15, 20} i=4 Second Loop Nothing Third Loop c[]={5, 10, 10, 15, 20, 20} j=2 c[]={5, 10, 10, 15, 20, 20, 30} j=3 Merge Function of Merge Sort Input: a[] = {12, 15, 22, 13, 32} |---------| |-----| low = 0 mid = 2 high = 4 Output: a[] = {12, 13, 17 , 22, 32} Input: a[] = {7, 10, 12, 14, 9} |-------------| |--| low = 0 mid = 3 high = 4 Output: a[] = {7, 10, 12, 14, 9} Implementation Idea a[] = {13, 18, 21, 45, 10, 15, 80} low = 0 mid = 3 high = 6 left[] = {13, 18, 21, 45} right[] = { 10, 15, 80} merge left and right array a[] = {10, 13, 15, 18, 21, 45, 80} Implementation func merge(a []int, low int, mid int, high int) { // Setting up auxilary array n1 := mid - low + 1 n2 := high - mid left := make([]int, n1) right := make([]int, n2) for i := 0; i < n1; i++ { left[i] = a[low+i] } for i := 0; i < n2; i++ { right[i] = a[mid+i+1] } // standard merge logic i := 0 j := 0 k := low for i < n1 && j < n2 { if left[i] < right[j] { a[k] = left[i] i++ k++ } else { a[k] = right[j] k++ j++ } } for i < n1 { a[k] = left[i] k++ i++ } for j < n2 { a[k] = right[j] k++ j++ } } Time complexity: \u03b8(n) Aux Space: \u03b8(n) Merge Sort Algorithm func mergeSort(arr []int, l, r int) { if r > l { // atleast 2 elements m := (l + r) / 2 mergeSort(arr, l, m) mergeSort(arr, m+1, r) merge(arr, l, m, r) } } Explaination Merge Sort Analysis","title":"Merge Sort"},{"location":"sorting/merge_sort.html#merge-sort","text":"","title":"Merge Sort"},{"location":"sorting/merge_sort.html#introduction","text":"Divide and Conquer Algorithm Divide Conquer Merge Stable Algorithm \u03b8(n log n) time and O(n) aux space Well suited for linked list. Works in O(1) aux space Used in external sorting In generate for array. Quick sort outperforms it.","title":"Introduction"},{"location":"sorting/merge_sort.html#merge-two-sorted-array","text":"Input: a[] = {12, 17, 22} b[] = {7, 8, 8, 17} Ouput: c[] = {7, 8, 8, 12, 17, 22} Input: a[] = {11, 11, 22} b[] = {33} Ouput: c[] = {11, 11, 22, 33}","title":"Merge Two Sorted Array"},{"location":"sorting/merge_sort.html#naive-solution","text":"package main import ( \"fmt\" \"sort\" ) type Person struct { id int name string } func main() { a := []int{10, 15, 20, 20} b := []int{1, 2, 13} c := merge(a, b) fmt.Println(c) } func merge(a []int, b []int) []int { c := make([]int, len(a)+len(b)) for i, ele := range a { c[i] = ele } for i, ele := range b { c[len(a)+i] = ele } sort.Ints(c) return c } Time Complexity: O((m+n) log(m+n)) Space Complexity: \u03b8(m+n) Dry Run: a[] = {10, 15, 20, 20} b[] = {1, 2, 13} After 1st Loop: c[] = {10, 15, 20, 20, , , _} After 2st Loop: c[] = {10, 15, 20, 20, 1, 2, 13} After Sorting: c[] = {1, 2, 10, 13, 15, 20, 20}","title":"Naive Solution"},{"location":"sorting/merge_sort.html#efficient-solution","text":"Initially i=0, j =0 if a[i] <= b[j] { append a[i]; i++} else append b[j]; j++ package main import \"fmt\" func main() { a := []int{5, 10, 15, 20} b := []int{10, 20, 30} res := merge(a, b) fmt.Println(res) } func merge(a []int, b []int) (result []int) { i := 0 j := 0 for i < len(a) && j < len(b) { if a[i] <= b[j] { result = append(result, a[i]) i++ } else { result = append(result, b[j]) j++ } } for i < len(a) { result = append(result, a[i]) i++ } for j < len(b) { result = append(result, b[j]) j++ } return } Time Complexity: \u03b8(m+n) Dry Run: a := {5, 10, 15, 20} b := {10, 20, 30} First Loop i=0, j=0 c[]={5} i=1 c[]={5, 10} i=2 c[]={5, 10, 10} j=1 c[]={5, 10, 10, 15} i=3 c[]={5, 10, 10, 15, 20} i=4 Second Loop Nothing Third Loop c[]={5, 10, 10, 15, 20, 20} j=2 c[]={5, 10, 10, 15, 20, 20, 30} j=3","title":"Efficient Solution"},{"location":"sorting/merge_sort.html#merge-function-of-merge-sort","text":"Input: a[] = {12, 15, 22, 13, 32} |---------| |-----| low = 0 mid = 2 high = 4 Output: a[] = {12, 13, 17 , 22, 32} Input: a[] = {7, 10, 12, 14, 9} |-------------| |--| low = 0 mid = 3 high = 4 Output: a[] = {7, 10, 12, 14, 9}","title":"Merge Function of Merge Sort"},{"location":"sorting/merge_sort.html#implementation-idea","text":"a[] = {13, 18, 21, 45, 10, 15, 80} low = 0 mid = 3 high = 6 left[] = {13, 18, 21, 45} right[] = { 10, 15, 80} merge left and right array a[] = {10, 13, 15, 18, 21, 45, 80}","title":"Implementation Idea"},{"location":"sorting/merge_sort.html#implementation","text":"func merge(a []int, low int, mid int, high int) { // Setting up auxilary array n1 := mid - low + 1 n2 := high - mid left := make([]int, n1) right := make([]int, n2) for i := 0; i < n1; i++ { left[i] = a[low+i] } for i := 0; i < n2; i++ { right[i] = a[mid+i+1] } // standard merge logic i := 0 j := 0 k := low for i < n1 && j < n2 { if left[i] < right[j] { a[k] = left[i] i++ k++ } else { a[k] = right[j] k++ j++ } } for i < n1 { a[k] = left[i] k++ i++ } for j < n2 { a[k] = right[j] k++ j++ } } Time complexity: \u03b8(n) Aux Space: \u03b8(n)","title":"Implementation"},{"location":"sorting/merge_sort.html#merge-sort-algorithm","text":"func mergeSort(arr []int, l, r int) { if r > l { // atleast 2 elements m := (l + r) / 2 mergeSort(arr, l, m) mergeSort(arr, m+1, r) merge(arr, l, m, r) } }","title":"Merge Sort Algorithm"},{"location":"sorting/merge_sort.html#explaination","text":"","title":"Explaination"},{"location":"sorting/merge_sort.html#merge-sort-analysis","text":"","title":"Merge Sort Analysis"},{"location":"sorting/selection_sort.html","text":"Selection Sort \u03b8(n 2 ) Algorithm Does less memory writes compared to quick sort, merge sort, insertion sor etc. But cycle sort is optimal in terms of memory writes Basic idea for heap sort Not stable In place: Does not require extra memory for sorting package main import \"fmt\" func main() { arr := []int{10, 3, 25, 17, 21, 55} // arr := []int{3, 10, 17, 21, 25, 55} selectionSort(arr) fmt.Println(arr) } func selectionSort(arr []int) { for i := 0; i < len(arr)-1; i++ { min_idx := i for j := i + 1; j < len(arr); j++ { if arr[j] < arr[min_idx] { min_idx = j } } arr[i], arr[min_idx] = arr[min_idx], arr[i] } } Time Complexity : \u03b8(n 2 ) Q. Why is it not stable. Ans: Given an array: arr[] = {90, 95, 90, 101 } 90 at 0th index will be swapped with 90 at 3rd index. So orginal order is not maintain when two elements are equal.","title":"Selection Sort"},{"location":"sorting/selection_sort.html#selection-sort","text":"\u03b8(n 2 ) Algorithm Does less memory writes compared to quick sort, merge sort, insertion sor etc. But cycle sort is optimal in terms of memory writes Basic idea for heap sort Not stable In place: Does not require extra memory for sorting package main import \"fmt\" func main() { arr := []int{10, 3, 25, 17, 21, 55} // arr := []int{3, 10, 17, 21, 25, 55} selectionSort(arr) fmt.Println(arr) } func selectionSort(arr []int) { for i := 0; i < len(arr)-1; i++ { min_idx := i for j := i + 1; j < len(arr); j++ { if arr[j] < arr[min_idx] { min_idx = j } } arr[i], arr[min_idx] = arr[min_idx], arr[i] } } Time Complexity : \u03b8(n 2 ) Q. Why is it not stable. Ans: Given an array: arr[] = {90, 95, 90, 101 } 90 at 0th index will be swapped with 90 at 3rd index. So orginal order is not maintain when two elements are equal.","title":"Selection Sort"},{"location":"string/anagram.html","text":"Check If Two Given Strings are Anagram or Not Example of anagram strings: Listen == Silent Triangle == Integral William Shakespeare == I am a weakish speller Note: The string may contain punctuations. You need to ignore punctuations Implementation","title":"Strign is Anagram"},{"location":"string/anagram.html#check-if-two-given-strings-are-anagram-or-not","text":"Example of anagram strings: Listen == Silent Triangle == Integral William Shakespeare == I am a weakish speller Note: The string may contain punctuations. You need to ignore punctuations","title":"Check If Two Given Strings are Anagram or Not"},{"location":"string/anagram.html#implementation","text":"","title":"Implementation"},{"location":"string/max_word_n_count.html","text":"Max occured word by d in given paragraph","title":"Max n Occurance of Word in Paragraph"},{"location":"string/max_word_n_count.html#max-occured-word-by-d-in-given-paragraph","text":"","title":"Max occured word by d in given paragraph"},{"location":"string/palindrom.html","text":"Check if a String is Palindrom or not Efficient Approach package main import \"fmt\" func main() { str := \"\u65e5\u672c\u8a9e\u672c\u65e5\" // true // str := \"\u65e5\u672c\u8a9e\u8a9e\u672c\" // false // str := \"\u65e5\u672c\u8a9e\u8a9e\u672c\u65e5\" // true // str := \"madam\" // true // str := \"maddam\" // true result := isPalindram(str) fmt.Println(result) } func isPalindram(str string) bool { chars := []rune(str) for i := 0; i < len(chars)/2; i++ { revIdx := len(chars) - i - 1 if chars[i] != chars[revIdx] { return false } } return true }","title":"String is Palindrom"},{"location":"string/palindrom.html#check-if-a-string-is-palindrom-or-not","text":"","title":"Check if a String is Palindrom or not"},{"location":"string/palindrom.html#efficient-approach","text":"package main import \"fmt\" func main() { str := \"\u65e5\u672c\u8a9e\u672c\u65e5\" // true // str := \"\u65e5\u672c\u8a9e\u8a9e\u672c\" // false // str := \"\u65e5\u672c\u8a9e\u8a9e\u672c\u65e5\" // true // str := \"madam\" // true // str := \"maddam\" // true result := isPalindram(str) fmt.Println(result) } func isPalindram(str string) bool { chars := []rune(str) for i := 0; i < len(chars)/2; i++ { revIdx := len(chars) - i - 1 if chars[i] != chars[revIdx] { return false } } return true }","title":"Efficient Approach"},{"location":"string/pangram.html","text":"Check if a String is Pangram or not A string is pangram if string contain a-z / A-Z alphabets alteast once. You can ignore the case. You need to consider only english alphabets and the string may contain punctuation marks. Also, you need to return how number of letter are missing if it is not pangram. Example of angram string: 1. The quick brown fox jumps over a lazy dog. 2. Mr. Jock, TV quiz PhD., bags few lynx. Initial Solution package main import ( \"fmt\" \"strings\" ) func main() { str := \"The quick brown fox jumps over a lazy dog.\" // true 0 // str := \"Mr. Jock, TV quiz PhD., bags few lynx.\" // true 0 // str := \"The quick brown fox jumps over the dog\" // false 4 result, count := isPangram(str) fmt.Println(result, count) } func isPangram(str string) (bool, int) { charMap := make(map[string]bool) for _, ele := range str { if (ele >= 'A' && ele <= 'Z') || (ele >= 'a' && ele <= 'z') { char := strings.ToLower(string(ele)) charMap[char] = true } } if len(charMap) == 26 { return true, 0 } return false, 26 - len(charMap) } Enhancement It should also show missing letters. package main import ( \"fmt\" \"strings\" ) func main() { // str := \"The quick brown fox jumps over a lazy dog.\" // true [] // str := \"Mr. Jock, TV quiz PhD., bags few lynx.\" // true [] str := \"The quick brown fox jumps over the dog\" // false [a l y z] result, count := isPangram(str) fmt.Println(result, count) } func isPangram(str string) (bool, []string) { charMap := make(map[string]bool) for _, ele := range str { if (ele >= 'A' && ele <= 'Z') || (ele >= 'a' && ele <= 'z') { char := strings.ToLower(string(ele)) charMap[char] = true } } var missingAlpha []string var i rune = 'a' for ; i <= 'z'; i++ { if !(charMap[string(i)]) { missingAlpha = append(missingAlpha, string(i)) } } if len(missingAlpha) == 0 { return true, missingAlpha } return false, missingAlpha }","title":"String is Pangram"},{"location":"string/pangram.html#check-if-a-string-is-pangram-or-not","text":"A string is pangram if string contain a-z / A-Z alphabets alteast once. You can ignore the case. You need to consider only english alphabets and the string may contain punctuation marks. Also, you need to return how number of letter are missing if it is not pangram. Example of angram string: 1. The quick brown fox jumps over a lazy dog. 2. Mr. Jock, TV quiz PhD., bags few lynx.","title":"Check if a String is Pangram or not"},{"location":"string/pangram.html#initial-solution","text":"package main import ( \"fmt\" \"strings\" ) func main() { str := \"The quick brown fox jumps over a lazy dog.\" // true 0 // str := \"Mr. Jock, TV quiz PhD., bags few lynx.\" // true 0 // str := \"The quick brown fox jumps over the dog\" // false 4 result, count := isPangram(str) fmt.Println(result, count) } func isPangram(str string) (bool, int) { charMap := make(map[string]bool) for _, ele := range str { if (ele >= 'A' && ele <= 'Z') || (ele >= 'a' && ele <= 'z') { char := strings.ToLower(string(ele)) charMap[char] = true } } if len(charMap) == 26 { return true, 0 } return false, 26 - len(charMap) }","title":"Initial Solution"},{"location":"string/pangram.html#enhancement","text":"It should also show missing letters. package main import ( \"fmt\" \"strings\" ) func main() { // str := \"The quick brown fox jumps over a lazy dog.\" // true [] // str := \"Mr. Jock, TV quiz PhD., bags few lynx.\" // true [] str := \"The quick brown fox jumps over the dog\" // false [a l y z] result, count := isPangram(str) fmt.Println(result, count) } func isPangram(str string) (bool, []string) { charMap := make(map[string]bool) for _, ele := range str { if (ele >= 'A' && ele <= 'Z') || (ele >= 'a' && ele <= 'z') { char := strings.ToLower(string(ele)) charMap[char] = true } } var missingAlpha []string var i rune = 'a' for ; i <= 'z'; i++ { if !(charMap[string(i)]) { missingAlpha = append(missingAlpha, string(i)) } } if len(missingAlpha) == 0 { return true, missingAlpha } return false, missingAlpha }","title":"Enhancement"},{"location":"string/subsequence.html","text":"Print All subssequence of the string Subsequence is not substring subsequence string can be generated by selecting charactor from the given string It should maintain the order Valid subsequence: abc and acd are subsequence of abcd Invalid subsequence: acb and dac is not subsequence of abcd because order is not maintained Ex1: Input: abcd Outout: [abcd abc abd ab acd ac ad a bcd bc bd b cd c d ] package main import \"fmt\" var arr []string func main() { arr = make([]string, 0) str := \"abcd\" subseq(str, \"\") fmt.Println(arr) } func subseq(str, ans string) { if len(str) == 0 { arr = append(arr, ans) return } firstChar := string([]rune(str)[0]) subseq(str[1:], ans+firstChar) subseq(str[1:], ans) }","title":"All subsequence of A string"},{"location":"string/subsequence.html#print-all-subssequence-of-the-string","text":"Subsequence is not substring subsequence string can be generated by selecting charactor from the given string It should maintain the order Valid subsequence: abc and acd are subsequence of abcd Invalid subsequence: acb and dac is not subsequence of abcd because order is not maintained Ex1: Input: abcd Outout: [abcd abc abd ab acd ac ad a bcd bc bd b cd c d ] package main import \"fmt\" var arr []string func main() { arr = make([]string, 0) str := \"abcd\" subseq(str, \"\") fmt.Println(arr) } func subseq(str, ans string) { if len(str) == 0 { arr = append(arr, ans) return } firstChar := string([]rune(str)[0]) subseq(str[1:], ans+firstChar) subseq(str[1:], ans) }","title":"Print All subssequence of the string"},{"location":"string/word_count.html","text":"Word count(ocurance of each word) in given paragraph","title":"Word cound in paragraph"},{"location":"string/word_count.html#word-countocurance-of-each-word-in-given-paragraph","text":"","title":"Word count(ocurance of each word) in given paragraph"}]}