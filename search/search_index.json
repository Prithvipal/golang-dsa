{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Data Structures and Algorithms using Golang Data Structures and Algorithms using Golang provides code implemention for DSA problem statements in golang . It shows time and space complexity for each solution. It does not explain theoretical concepts of DSA but providers different level(Naive, Efficient and More Efficient) of programming solution for problem statement.","title":"Home"},{"location":"#data-structures-and-algorithms-using-golang","text":"Data Structures and Algorithms using Golang provides code implemention for DSA problem statements in golang . It shows time and space complexity for each solution. It does not explain theoretical concepts of DSA but providers different level(Naive, Efficient and More Efficient) of programming solution for problem statement.","title":"Data Structures and Algorithms using Golang"},{"location":"about/","text":"About Prithvipal Singh Prithvipal Singh is software engineer having more than 8 years of experience. He is experience in Golang, Java, Kubernetes, Docker, Microservice architecture, Cloud Computing. Currently, he is exploring edge computing. He looks to contribute in open source code. He is an author of Hands on go programming book. Social Media Let us connect. LinkedIn: https://www.linkedin.com/in/prithvipal-singh-2a7b4b49/ Twiter: https://twitter.com/prithvirathor99","title":"About"},{"location":"about/#about-prithvipal-singh","text":"Prithvipal Singh is software engineer having more than 8 years of experience. He is experience in Golang, Java, Kubernetes, Docker, Microservice architecture, Cloud Computing. Currently, he is exploring edge computing. He looks to contribute in open source code. He is an author of Hands on go programming book.","title":"About Prithvipal Singh"},{"location":"about/#social-media","text":"Let us connect. LinkedIn: https://www.linkedin.com/in/prithvipal-singh-2a7b4b49/ Twiter: https://twitter.com/prithvirathor99","title":"Social Media"},{"location":"array/frequency_sorted_array/","text":"Frequency in a Sorted Array Input: arr[] = {12, 12, 12, 23, 43, 43} Output: 12 -> 3 23 -> 1 43 -> 2 Input: arr[] = {14, 14, 14, 14} Output: 14 -> 4 Input: arr[] = {101, 102, 103} Output: 101 -> 1 102 -> 1 103 -> 1 Implementation package main import \"fmt\" func main() { arr := []int{10} // arr := []int{12, 12, 12, 23, 43, 43} // arr := []int{14, 14, 14, 14} // arr := []int{101, 102, 103} printFreq(arr) } func printFreq(arr []int) { freq := 1 i := 1 for i < len(arr) { for i < len(arr) && arr[i] == arr[i-1] { i++ freq++ } fmt.Printf(\"%d -> %d\\n\", arr[i-1], freq) i++ freq = 1 } if len(arr) == 1 || arr[i-2] != arr[i-3] { fmt.Printf(\"%d --> %d\\n\", arr[len(arr)-1], 1) } } Time Complexity: \u03b8(n) Note: Since we are increamenting i in both for loop (outer and inner). As soon as i becomes equal to n, the loop stops. So total number of iterations are inner+outer loops. Time complexity is exactly n.","title":"Frequency in Sorted Array"},{"location":"array/frequency_sorted_array/#frequency-in-a-sorted-array","text":"Input: arr[] = {12, 12, 12, 23, 43, 43} Output: 12 -> 3 23 -> 1 43 -> 2 Input: arr[] = {14, 14, 14, 14} Output: 14 -> 4 Input: arr[] = {101, 102, 103} Output: 101 -> 1 102 -> 1 103 -> 1","title":"Frequency in a Sorted Array"},{"location":"array/frequency_sorted_array/#implementation","text":"package main import \"fmt\" func main() { arr := []int{10} // arr := []int{12, 12, 12, 23, 43, 43} // arr := []int{14, 14, 14, 14} // arr := []int{101, 102, 103} printFreq(arr) } func printFreq(arr []int) { freq := 1 i := 1 for i < len(arr) { for i < len(arr) && arr[i] == arr[i-1] { i++ freq++ } fmt.Printf(\"%d -> %d\\n\", arr[i-1], freq) i++ freq = 1 } if len(arr) == 1 || arr[i-2] != arr[i-3] { fmt.Printf(\"%d --> %d\\n\", arr[len(arr)-1], 1) } } Time Complexity: \u03b8(n) Note: Since we are increamenting i in both for loop (outer and inner). As soon as i becomes equal to n, the loop stops. So total number of iterations are inner+outer loops. Time complexity is exactly n.","title":"Implementation"},{"location":"array/intro/","text":"Introduction of Array Continuous memory allocation Advantages Random Access Cache friendliness","title":"Introduction"},{"location":"array/intro/#introduction-of-array","text":"Continuous memory allocation Advantages Random Access Cache friendliness","title":"Introduction of Array"},{"location":"array/is_array_sorted/","text":"Check If An Array is Sorted Input: arr[] = {18, 25, 27} Output: Yes Input: arr[] = {18, 30, 30, 99} Output: Yes Input: arr[] = {100} Output: Yes Input: arr[] = {100, 20, 200} Output: No Note - We are only considering array wheree array are in assending order - It there are duplicate then is also true. Ex. 2nd example above Naive Approach package main import ( \"fmt\" ) func main() { arr := []int{18, 25, 27} // Yes // arr := []int{18, 30, 30, 99} // Yes // arr := []int{100} // Yes // arr := []int{100, 20, 200} // No result := isArraySorted(arr) if result { fmt.Println(\"Yes\") } else { fmt.Println(\"No\") } } func isArraySorted(arr []int) bool { for i := 0; i < len(arr); i++ { for j := i + 1; j < len(arr); j++ { if arr[i] > arr[j] { return false } } } return true } Time Complexity: O(n2) Efficient Approach package main import ( \"fmt\" ) func main() { // arr := []int{18, 25, 27} // Yes // arr := []int{18, 30, 30, 99} // Yes // arr := []int{100} // Yes arr := []int{100, 20, 200} // No result := isArraySorted(arr) if result { fmt.Println(\"Yes\") } else { fmt.Println(\"No\") } } func isArraySorted(arr []int) bool { for i := 0; i < len(arr)-2; i++ { if arr[i] > arr[i+1] { return false } } return true } Time Complexity: O(n)","title":"Check If Array is Sorted"},{"location":"array/is_array_sorted/#check-if-an-array-is-sorted","text":"Input: arr[] = {18, 25, 27} Output: Yes Input: arr[] = {18, 30, 30, 99} Output: Yes Input: arr[] = {100} Output: Yes Input: arr[] = {100, 20, 200} Output: No Note - We are only considering array wheree array are in assending order - It there are duplicate then is also true. Ex. 2nd example above","title":"Check If An Array is Sorted"},{"location":"array/is_array_sorted/#naive-approach","text":"package main import ( \"fmt\" ) func main() { arr := []int{18, 25, 27} // Yes // arr := []int{18, 30, 30, 99} // Yes // arr := []int{100} // Yes // arr := []int{100, 20, 200} // No result := isArraySorted(arr) if result { fmt.Println(\"Yes\") } else { fmt.Println(\"No\") } } func isArraySorted(arr []int) bool { for i := 0; i < len(arr); i++ { for j := i + 1; j < len(arr); j++ { if arr[i] > arr[j] { return false } } } return true } Time Complexity: O(n2)","title":"Naive Approach"},{"location":"array/is_array_sorted/#efficient-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{18, 25, 27} // Yes // arr := []int{18, 30, 30, 99} // Yes // arr := []int{100} // Yes arr := []int{100, 20, 200} // No result := isArraySorted(arr) if result { fmt.Println(\"Yes\") } else { fmt.Println(\"No\") } } func isArraySorted(arr []int) bool { for i := 0; i < len(arr)-2; i++ { if arr[i] > arr[i+1] { return false } } return true } Time Complexity: O(n)","title":"Efficient Approach"},{"location":"array/largest_element/","text":"Largest element in array package main import \"fmt\" func main() { arr := []int{10, 52, 18, 20} largest := getLargest(arr) fmt.Println(\"largest element at index\", largest) fmt.Println(\"largest element\", arr[largest]) } func getLargest(arr []int) int { largest := 0 for i := 1; i < len(arr); i++ { if arr[i] > arr[largest] { largest = i } } return largest } Time Complexity: O(n)","title":"Largest Element in Array"},{"location":"array/largest_element/#largest-element-in-array","text":"package main import \"fmt\" func main() { arr := []int{10, 52, 18, 20} largest := getLargest(arr) fmt.Println(\"largest element at index\", largest) fmt.Println(\"largest element\", arr[largest]) } func getLargest(arr []int) int { largest := 0 for i := 1; i < len(arr); i++ { if arr[i] > arr[largest] { largest = i } } return largest } Time Complexity: O(n)","title":"Largest element in array"},{"location":"array/leaders_in_array/","text":"Leaders in an Array Input: arr[] = {17, 20, 14, 13, 16, 15, 12} Output: {20, 16, 15, 12} Input: arr[] = {10, 20, 30} Output: {30} Input: arr[] = {25, 15, 10} Output: {25, 15, 10} Leader in an array is the element that there is no larger than the element to its right side. Left most is always be leader because there is no large then that element to its right side. If there are duplicate elements then first occurance can be considers as leader. We can consider last occurance because we are say larger but not equal. Ex: {9, 11, 6, 11, 8, 7, 2} :: here can not consider 11 of 1st index. we can condier 11 of 3rd index. Naive Approach package main import ( \"fmt\" ) func main() { // arr := []int{17, 20, 14, 13, 16, 15, 12} // 20 16 15 12 // arr := []int{10, 20, 30} // 30 arr := []int{25, 15, 10} leader(arr) } func leader(arr []int) { for i := 0; i < len(arr); i++ { flag := false for j := i + 1; j < len(arr); j++ { if arr[i] <= arr[j] { flag = true break } } if !flag { fmt.Printf(\"%d \", arr[i]) } } fmt.Println() } Time Complexity: O(n 2 ) Efficient Approach package main import ( \"fmt\" ) func main() { arr := []int{17, 20, 14, 13, 16, 15, 12} // 12 15 16 20 // arr := []int{10, 20, 30} // 30 // arr := []int{25, 15, 10} // 10 15 25 leader(arr) } func leader(arr []int) { curLeader := arr[len(arr)-1] fmt.Printf(\"%d \", curLeader) for i := len(arr) - 2; i >= 0; i-- { if curLeader < arr[i] { curLeader = arr[i] fmt.Printf(\"%d \", curLeader) } } fmt.Println() } Time Complexity: \u03b8(n) Note: It will print leaders in reverse order If we want to print in same order as we have in array, then we can store leaders in a new array and then we can iterate new array in reverse order and print each element.","title":"Leaders in Array"},{"location":"array/leaders_in_array/#leaders-in-an-array","text":"Input: arr[] = {17, 20, 14, 13, 16, 15, 12} Output: {20, 16, 15, 12} Input: arr[] = {10, 20, 30} Output: {30} Input: arr[] = {25, 15, 10} Output: {25, 15, 10} Leader in an array is the element that there is no larger than the element to its right side. Left most is always be leader because there is no large then that element to its right side. If there are duplicate elements then first occurance can be considers as leader. We can consider last occurance because we are say larger but not equal. Ex: {9, 11, 6, 11, 8, 7, 2} :: here can not consider 11 of 1st index. we can condier 11 of 3rd index.","title":"Leaders in an Array"},{"location":"array/leaders_in_array/#naive-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{17, 20, 14, 13, 16, 15, 12} // 20 16 15 12 // arr := []int{10, 20, 30} // 30 arr := []int{25, 15, 10} leader(arr) } func leader(arr []int) { for i := 0; i < len(arr); i++ { flag := false for j := i + 1; j < len(arr); j++ { if arr[i] <= arr[j] { flag = true break } } if !flag { fmt.Printf(\"%d \", arr[i]) } } fmt.Println() } Time Complexity: O(n 2 )","title":"Naive Approach"},{"location":"array/leaders_in_array/#efficient-approach","text":"package main import ( \"fmt\" ) func main() { arr := []int{17, 20, 14, 13, 16, 15, 12} // 12 15 16 20 // arr := []int{10, 20, 30} // 30 // arr := []int{25, 15, 10} // 10 15 25 leader(arr) } func leader(arr []int) { curLeader := arr[len(arr)-1] fmt.Printf(\"%d \", curLeader) for i := len(arr) - 2; i >= 0; i-- { if curLeader < arr[i] { curLeader = arr[i] fmt.Printf(\"%d \", curLeader) } } fmt.Println() } Time Complexity: \u03b8(n) Note: It will print leaders in reverse order If we want to print in same order as we have in array, then we can store leaders in a new array and then we can iterate new array in reverse order and print each element.","title":"Efficient Approach"},{"location":"array/left_rotate_array_by_d/","text":"Left Rotate Array by d Input: arr[] = {11, 22, 33, 44, 55} d = 2 Output: arr[] = {33, 44, 55, 11, 22} Input: arr[] = {11, 15, 33, 19} d = 3 Output: arr[] = {19, 11, 15, 33} We may assume that d <= No of elements in array If d > no of elements in array then we can simply d = d-n Naive Approach package main import ( \"fmt\" ) func main() { // arr := []int{11, 22, 33, 44, 55} // [33 44 55 11 22] // leftRotate(arr, 2) // fmt.Println(arr) arr := []int{11, 15, 33, 19} // [19 11 15 33] leftRotate(arr, 3) fmt.Println(arr) } func leftRotate(arr []int, d int) { for i := 0; i < d; i++ { leftRotateOne(arr) } } func leftRotateOne(arr []int) { temp := arr[0] for i := 1; i < len(arr); i++ { arr[i-1] = arr[i] } arr[len(arr)-1] = temp } Time Complexity: \u03b8(n * d) Aux Space: \u03b8(1) Better Approach package main import ( \"fmt\" ) func main() { arr := []int{11, 22, 33, 44, 55} // [33 44 55 11 22] leftRotate(arr, 2) fmt.Println(arr) // arr := []int{11, 15, 33, 19} // [19 11 15 33] // leftRotate(arr, 3) // fmt.Println(arr) } func leftRotate(arr []int, d int) { var temp []int for i := 0; i < d; i++ { temp = append(temp, arr[i]) } for i := d; i < len(arr); i++ { arr[i-d] = arr[i] } for i := range temp { arr[len(arr)-d+i] = temp[i] } } Time Complexity: \u03b8(d+ (n-d) + d) = \u03b8(n+d) = \u03b8(n) d is smaller than n so ignore d Aux Space: \u03b8(d) Best Approach package main import ( \"fmt\" ) func main() { // arr := []int{11, 22, 33, 44, 55} // [33 44 55 11 22] // leftRotate(arr, 2) // fmt.Println(arr) arr := []int{11, 15, 33, 19} // [19 11 15 33] leftRotate(arr, 3) fmt.Println(arr) } func reverve(arr []int, low, high int) { for low < high { temp := arr[low] arr[low] = arr[high] arr[high] = temp low++ high-- } } func leftRotate(arr []int, d int) { reverve(arr, 0, d-1) reverve(arr, d, len(arr)-1) reverve(arr, 0, len(arr)-1) } Time Complexity: \u03b8(d + (n-d) + n) = \u03b8(2n) = \u03b8(n) Aux Space: \u03b8(1)","title":"Left Rotate Array by d"},{"location":"array/left_rotate_array_by_d/#left-rotate-array-by-d","text":"Input: arr[] = {11, 22, 33, 44, 55} d = 2 Output: arr[] = {33, 44, 55, 11, 22} Input: arr[] = {11, 15, 33, 19} d = 3 Output: arr[] = {19, 11, 15, 33} We may assume that d <= No of elements in array If d > no of elements in array then we can simply d = d-n","title":"Left Rotate Array by d"},{"location":"array/left_rotate_array_by_d/#naive-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{11, 22, 33, 44, 55} // [33 44 55 11 22] // leftRotate(arr, 2) // fmt.Println(arr) arr := []int{11, 15, 33, 19} // [19 11 15 33] leftRotate(arr, 3) fmt.Println(arr) } func leftRotate(arr []int, d int) { for i := 0; i < d; i++ { leftRotateOne(arr) } } func leftRotateOne(arr []int) { temp := arr[0] for i := 1; i < len(arr); i++ { arr[i-1] = arr[i] } arr[len(arr)-1] = temp } Time Complexity: \u03b8(n * d) Aux Space: \u03b8(1)","title":"Naive Approach"},{"location":"array/left_rotate_array_by_d/#better-approach","text":"package main import ( \"fmt\" ) func main() { arr := []int{11, 22, 33, 44, 55} // [33 44 55 11 22] leftRotate(arr, 2) fmt.Println(arr) // arr := []int{11, 15, 33, 19} // [19 11 15 33] // leftRotate(arr, 3) // fmt.Println(arr) } func leftRotate(arr []int, d int) { var temp []int for i := 0; i < d; i++ { temp = append(temp, arr[i]) } for i := d; i < len(arr); i++ { arr[i-d] = arr[i] } for i := range temp { arr[len(arr)-d+i] = temp[i] } } Time Complexity: \u03b8(d+ (n-d) + d) = \u03b8(n+d) = \u03b8(n) d is smaller than n so ignore d Aux Space: \u03b8(d)","title":"Better Approach"},{"location":"array/left_rotate_array_by_d/#best-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{11, 22, 33, 44, 55} // [33 44 55 11 22] // leftRotate(arr, 2) // fmt.Println(arr) arr := []int{11, 15, 33, 19} // [19 11 15 33] leftRotate(arr, 3) fmt.Println(arr) } func reverve(arr []int, low, high int) { for low < high { temp := arr[low] arr[low] = arr[high] arr[high] = temp low++ high-- } } func leftRotate(arr []int, d int) { reverve(arr, 0, d-1) reverve(arr, d, len(arr)-1) reverve(arr, 0, len(arr)-1) } Time Complexity: \u03b8(d + (n-d) + n) = \u03b8(2n) = \u03b8(n) Aux Space: \u03b8(1)","title":"Best Approach"},{"location":"array/left_rotate_array_by_one/","text":"Left Rotate an Array by One Input: arr[] = {11, 22, 33, 44, 55} Output: arr[] = {22, 33, 44, 55, 11} Input: arr[] = {50, 3, 22} Output: arr[] = {3, 22, 50} package main import ( \"fmt\" ) func main() { // arr := []int{11, 22, 33, 44, 55} // [22 33 44 55 11] arr := []int{50, 3, 22} // [3 22 50] leftRotateOne(arr) fmt.Println(arr) } func leftRotateOne(arr []int) { temp := arr[0] for i := 1; i < len(arr); i++ { arr[i-1] = arr[i] } arr[len(arr)-1] = temp } Time Complexity: \u03b8(n) Space Complexity: \u03b8(1)","title":"Left Rotate Array by One"},{"location":"array/left_rotate_array_by_one/#left-rotate-an-array-by-one","text":"Input: arr[] = {11, 22, 33, 44, 55} Output: arr[] = {22, 33, 44, 55, 11} Input: arr[] = {50, 3, 22} Output: arr[] = {3, 22, 50} package main import ( \"fmt\" ) func main() { // arr := []int{11, 22, 33, 44, 55} // [22 33 44 55 11] arr := []int{50, 3, 22} // [3 22 50] leftRotateOne(arr) fmt.Println(arr) } func leftRotateOne(arr []int) { temp := arr[0] for i := 1; i < len(arr); i++ { arr[i-1] = arr[i] } arr[len(arr)-1] = temp } Time Complexity: \u03b8(n) Space Complexity: \u03b8(1)","title":"Left Rotate an Array by One"},{"location":"array/maximum_difference/","text":"Maximum Differences Maximum value of a[j] > a[i] such that j>i Input: arr[] = {3, 4, 11, 7, 5, 9, 1} Outout: 8 Input: arr[] = {8, 10, 6, 7, 4, 2} Outout: 2 Input: arr[] = {20, 30, 40} Output: 20 Here array is sorted so max diff is last element minus first element. Input: arr[] = {40, 30, 6, 4} Output: -2 Here array is reverse sorted then output will be negative Naive Approach package main import ( \"fmt\" ) func main() { arr := []int{3, 4, 11, 7, 5, 9, 1} // 8 // arr := []int{8, 10, 6, 7, 4, 2} // 2 // arr := []int{20, 30, 40} // 20 // arr := []int{40, 30, 6, 4} // -2 result := maxDiff(arr) fmt.Println(result) } func maxDiff(arr []int) int { result := arr[1] - arr[0] for i := 0; i < len(arr); i++ { for j := i + 1; j < len(arr); j++ { result = max(result, arr[j]-arr[i]) } } return result } func max(a, b int) int { if a > b { return a } return b } Time complexity: \u03b8(n 2 ) Efficient Approach package main import ( \"fmt\" ) func main() { arr := []int{3, 4, 11, 7, 5, 9, 1} // 8 // arr := []int{8, 10, 6, 7, 4, 2} // 2 // arr := []int{20, 30, 40} // 20 // arr := []int{40, 30, 6, 4} // -2 result := maxDiff(arr) fmt.Println(result) } func maxDiff(arr []int) int { result := arr[1] - arr[0] minVal := arr[0] for i := 1; i < len(arr); i++ { result = max(result, arr[i]-minVal) minVal = min(minVal, arr[i]) } return result } func max(a, b int) int { if a > b { return a } return b } func min(a, b int) int { if a < b { return a } return b } Time Complexity: \u03b8(n) Aux Space: \u03b8(1)","title":"Maximum Difference"},{"location":"array/maximum_difference/#maximum-differences","text":"Maximum value of a[j] > a[i] such that j>i Input: arr[] = {3, 4, 11, 7, 5, 9, 1} Outout: 8 Input: arr[] = {8, 10, 6, 7, 4, 2} Outout: 2 Input: arr[] = {20, 30, 40} Output: 20 Here array is sorted so max diff is last element minus first element. Input: arr[] = {40, 30, 6, 4} Output: -2 Here array is reverse sorted then output will be negative","title":"Maximum Differences"},{"location":"array/maximum_difference/#naive-approach","text":"package main import ( \"fmt\" ) func main() { arr := []int{3, 4, 11, 7, 5, 9, 1} // 8 // arr := []int{8, 10, 6, 7, 4, 2} // 2 // arr := []int{20, 30, 40} // 20 // arr := []int{40, 30, 6, 4} // -2 result := maxDiff(arr) fmt.Println(result) } func maxDiff(arr []int) int { result := arr[1] - arr[0] for i := 0; i < len(arr); i++ { for j := i + 1; j < len(arr); j++ { result = max(result, arr[j]-arr[i]) } } return result } func max(a, b int) int { if a > b { return a } return b } Time complexity: \u03b8(n 2 )","title":"Naive Approach"},{"location":"array/maximum_difference/#efficient-approach","text":"package main import ( \"fmt\" ) func main() { arr := []int{3, 4, 11, 7, 5, 9, 1} // 8 // arr := []int{8, 10, 6, 7, 4, 2} // 2 // arr := []int{20, 30, 40} // 20 // arr := []int{40, 30, 6, 4} // -2 result := maxDiff(arr) fmt.Println(result) } func maxDiff(arr []int) int { result := arr[1] - arr[0] minVal := arr[0] for i := 1; i < len(arr); i++ { result = max(result, arr[i]-minVal) minVal = min(minVal, arr[i]) } return result } func max(a, b int) int { if a > b { return a } return b } func min(a, b int) int { if a < b { return a } return b } Time Complexity: \u03b8(n) Aux Space: \u03b8(1)","title":"Efficient Approach"},{"location":"array/move_all_zeroes_to_end/","text":"Move All Zeroes to End Input: arr[] = {18, 13, 0, 30, 0, 40} Output: arr[] = {18, 13, 30, 40, 0, 0} Input: arr[] = {0, 0, 0, 20, 0} Output: arr[] = {20, 0, 0, 0} Input: arr[] = {50, 66} Output: arr[] = {50, 66} Noive Approach package main import ( \"fmt\" ) func main() { // arr := []int{18, 13, 0, 30, 0, 40} // [18 13 40 30 0 0] // arr := []int{0, 0, 0, 20, 0} // [20 0 0 0 0] arr := []int{50, 66} // [50 66] moveToEnd(arr) fmt.Println(arr) } func moveToEnd(arr []int) { for i := 0; i < len(arr); i++ { if arr[i] == 0 { for j := i + 1; j < len(arr); j++ { if arr[j] != 0 { arr[i], arr[j] = swap(arr[i], arr[j]) } } } } } func swap(a, b int) (int, int) { return b, a } Time Complexity: O(n*n) Efficient Approach package main import ( \"fmt\" ) func main() { // arr := []int{18, 13, 0, 30, 0, 40} // [18 13 40 30 0 0] // arr := []int{0, 0, 0, 20, 0} // [20 0 0 0 0] arr := []int{50, 66} // [50 66] moveToEnd(arr) fmt.Println(arr) } func moveToEnd(arr []int) { count := 0 for i := 0; i < len(arr); i++ { if arr[i] != 0 { arr[i], arr[count] = swap(arr[i], arr[count]) count++ } } } func swap(a, b int) (int, int) { return b, a } Time Complexity: O(n)","title":"Move All Zeroes to End"},{"location":"array/move_all_zeroes_to_end/#move-all-zeroes-to-end","text":"Input: arr[] = {18, 13, 0, 30, 0, 40} Output: arr[] = {18, 13, 30, 40, 0, 0} Input: arr[] = {0, 0, 0, 20, 0} Output: arr[] = {20, 0, 0, 0} Input: arr[] = {50, 66} Output: arr[] = {50, 66}","title":"Move All Zeroes to End"},{"location":"array/move_all_zeroes_to_end/#noive-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{18, 13, 0, 30, 0, 40} // [18 13 40 30 0 0] // arr := []int{0, 0, 0, 20, 0} // [20 0 0 0 0] arr := []int{50, 66} // [50 66] moveToEnd(arr) fmt.Println(arr) } func moveToEnd(arr []int) { for i := 0; i < len(arr); i++ { if arr[i] == 0 { for j := i + 1; j < len(arr); j++ { if arr[j] != 0 { arr[i], arr[j] = swap(arr[i], arr[j]) } } } } } func swap(a, b int) (int, int) { return b, a } Time Complexity: O(n*n)","title":"Noive Approach"},{"location":"array/move_all_zeroes_to_end/#efficient-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{18, 13, 0, 30, 0, 40} // [18 13 40 30 0 0] // arr := []int{0, 0, 0, 20, 0} // [20 0 0 0 0] arr := []int{50, 66} // [50 66] moveToEnd(arr) fmt.Println(arr) } func moveToEnd(arr []int) { count := 0 for i := 0; i < len(arr); i++ { if arr[i] != 0 { arr[i], arr[count] = swap(arr[i], arr[count]) count++ } } } func swap(a, b int) (int, int) { return b, a } Time Complexity: O(n)","title":"Efficient Approach"},{"location":"array/operations/","text":"Operations Search (unsorted array) package main import \"fmt\" func main() { arr := []int{10, 3, 6, 14, 17} result := search(arr, 14) if result == -1 { fmt.Println(\"Element not found\") } else { fmt.Println(\"Element found at index:\", result) } } func search(arr []int, ele int) int { for i := 0; i < len(arr); i++ { if arr[i] == ele { return i } } return -1 } Time Complexity: O(n)","title":"Operation in Array"},{"location":"array/operations/#operations","text":"","title":"Operations"},{"location":"array/operations/#search-unsorted-array","text":"package main import \"fmt\" func main() { arr := []int{10, 3, 6, 14, 17} result := search(arr, 14) if result == -1 { fmt.Println(\"Element not found\") } else { fmt.Println(\"Element found at index:\", result) } } func search(arr []int, ele int) int { for i := 0; i < len(arr); i++ { if arr[i] == ele { return i } } return -1 } Time Complexity: O(n)","title":"Search (unsorted array)"},{"location":"array/remove_duplicates_from_sorted_array/","text":"Remove Duplicates from Sorted Array Input: arr[] = {12, 15, 15, 20, 20, 20, 20} length: 7 Output: arr[] = {12, 15, 20} length: 3 Input: arr[] = {16, 16, 16} length: 3 Output: arr[] = {16} length: 1 Naive Approach package main import ( \"fmt\" ) func main() { // arr := []int{12, 15, 15, 20, 20, 20, 20} // [12 15 20] arr := []int{16, 16, 16} // [16] result := removeDups(arr) fmt.Println(\"arr[] =\", result) fmt.Println(\"length =\", len(result)) } func removeDups(arr []int) []int { var temp []int temp = append(temp, arr[0]) result := 1 for i := 1; i < len(arr); i++ { if temp[result-1] != arr[i] { temp = append(temp, arr[i]) result++ } } for i := 0; i < result; i++ { arr[i] = temp[i] } return arr[:result] } Time Complexity: O(n) Space Complexity: O(n) Efficient Approach package main import ( \"fmt\" ) func main() { // arr := []int{12, 15, 15, 20, 20, 20, 20} // [12 15 20] arr := []int{16, 16, 16} // [16] result := removeDups(arr) fmt.Println(\"arr[] =\", result) fmt.Println(\"length =\", len(result)) } func removeDups(arr []int) []int { result := 1 for i := 1; i < len(arr); i++ { if arr[i] != arr[result-1] { arr[result] = arr[i] result++ } } return arr[:result] } Time Complexity: O(n) Space Complexity: O(1) Note: we are using result variable to keep track to unique elements in array.","title":"Remove Duplicate from Sorted Array"},{"location":"array/remove_duplicates_from_sorted_array/#remove-duplicates-from-sorted-array","text":"Input: arr[] = {12, 15, 15, 20, 20, 20, 20} length: 7 Output: arr[] = {12, 15, 20} length: 3 Input: arr[] = {16, 16, 16} length: 3 Output: arr[] = {16} length: 1","title":"Remove Duplicates from Sorted Array"},{"location":"array/remove_duplicates_from_sorted_array/#naive-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{12, 15, 15, 20, 20, 20, 20} // [12 15 20] arr := []int{16, 16, 16} // [16] result := removeDups(arr) fmt.Println(\"arr[] =\", result) fmt.Println(\"length =\", len(result)) } func removeDups(arr []int) []int { var temp []int temp = append(temp, arr[0]) result := 1 for i := 1; i < len(arr); i++ { if temp[result-1] != arr[i] { temp = append(temp, arr[i]) result++ } } for i := 0; i < result; i++ { arr[i] = temp[i] } return arr[:result] } Time Complexity: O(n) Space Complexity: O(n)","title":"Naive Approach"},{"location":"array/remove_duplicates_from_sorted_array/#efficient-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{12, 15, 15, 20, 20, 20, 20} // [12 15 20] arr := []int{16, 16, 16} // [16] result := removeDups(arr) fmt.Println(\"arr[] =\", result) fmt.Println(\"length =\", len(result)) } func removeDups(arr []int) []int { result := 1 for i := 1; i < len(arr); i++ { if arr[i] != arr[result-1] { arr[result] = arr[i] result++ } } return arr[:result] } Time Complexity: O(n) Space Complexity: O(1) Note: we are using result variable to keep track to unique elements in array.","title":"Efficient Approach"},{"location":"array/remove_duplicates_from_unsorted_array/","text":"Remove Duplicates from Un-sorted Array Implementation package main import \"fmt\" func main() { arr := []int{10, 12, 8, 10, 12} result := removeDups(arr) fmt.Println(result) } func removeDups(arr []int) []int { var tempArr []int m := make(map[int]bool) for _, ele := range arr { if _, ok := m[ele]; !ok { m[ele] = true tempArr = append(tempArr, ele) } } return tempArr }","title":"Remove Duplicate from Unsorted Array"},{"location":"array/remove_duplicates_from_unsorted_array/#remove-duplicates-from-un-sorted-array","text":"","title":"Remove Duplicates from Un-sorted Array"},{"location":"array/remove_duplicates_from_unsorted_array/#implementation","text":"package main import \"fmt\" func main() { arr := []int{10, 12, 8, 10, 12} result := removeDups(arr) fmt.Println(result) } func removeDups(arr []int) []int { var tempArr []int m := make(map[int]bool) for _, ele := range arr { if _, ok := m[ele]; !ok { m[ele] = true tempArr = append(tempArr, ele) } } return tempArr }","title":"Implementation"},{"location":"array/reverse_array/","text":"Reverse an Array Input: arr[] = {12, 7, 9, 33} Output arr[] = {33, 9, 7, 12} Input: arr[] = {33, 22, 9, 3, 99} Output: arr[] = {99, 3, 9, 22, 33} Approach One package main import ( \"fmt\" ) func main() { arr := []int{12, 7, 9, 33} // [33 9 7 12] // arr := []int{33, 22, 9, 3, 99} // [99 3 9 22 33 reserveArray(arr) fmt.Println(arr) } func reserveArray(arr []int) { low := 0 high := len(arr) - 1 for low < high { temp := arr[low] arr[low] = arr[high] arr[high] = temp low++ high-- } } Time Complexity: : \u03b8(n) Aux Space: \u03b8(1) Approach Two package main import ( \"fmt\" ) func main() { // arr := []int{12, 7, 9, 33} // [33 9 7 12] arr := []int{33, 22, 9, 3, 99} // [99 3 9 22 33 reverseArray(arr) fmt.Println(arr) } func reverseArray(arr []int) { for i := 0; i < len(arr)/2; i++ { temp := arr[i] j := len(arr) - i - 1 arr[i] = arr[j] arr[j] = temp } } Time Complexity: : \u03b8(n) Aux Space: \u03b8(1)","title":"Reverse an Array"},{"location":"array/reverse_array/#reverse-an-array","text":"Input: arr[] = {12, 7, 9, 33} Output arr[] = {33, 9, 7, 12} Input: arr[] = {33, 22, 9, 3, 99} Output: arr[] = {99, 3, 9, 22, 33}","title":"Reverse an Array"},{"location":"array/reverse_array/#approach-one","text":"package main import ( \"fmt\" ) func main() { arr := []int{12, 7, 9, 33} // [33 9 7 12] // arr := []int{33, 22, 9, 3, 99} // [99 3 9 22 33 reserveArray(arr) fmt.Println(arr) } func reserveArray(arr []int) { low := 0 high := len(arr) - 1 for low < high { temp := arr[low] arr[low] = arr[high] arr[high] = temp low++ high-- } } Time Complexity: : \u03b8(n) Aux Space: \u03b8(1)","title":"Approach One"},{"location":"array/reverse_array/#approach-two","text":"package main import ( \"fmt\" ) func main() { // arr := []int{12, 7, 9, 33} // [33 9 7 12] arr := []int{33, 22, 9, 3, 99} // [99 3 9 22 33 reverseArray(arr) fmt.Println(arr) } func reverseArray(arr []int) { for i := 0; i < len(arr)/2; i++ { temp := arr[i] j := len(arr) - i - 1 arr[i] = arr[j] arr[j] = temp } } Time Complexity: : \u03b8(n) Aux Space: \u03b8(1)","title":"Approach Two"},{"location":"array/second_largest_element/","text":"Second Largest Element in Array Input: arr[] = {10, 5, 6, 15} Output: 0 // index of 10 Input: arr[] = {30, 15, 23, 9, 28} Output: 4 // index of 28 Inpute: arr[] = {15, 15, 15} Output: -1 // No second element Naive Approach package main import ( \"fmt\" ) func main() { // arr := []int{10, 5, 6, 15} // arr := []int{30, 15, 23, 9, 28} arr := []int{15, 15, 15} secLargest := getSecondLargest(arr) if secLargest == -1 { fmt.Println(\"No sencond largest found\") } else { fmt.Println(\"largest element at index\", secLargest) fmt.Println(\"largest element\", arr[secLargest]) } } func getLargest(arr []int) int { largest := 0 for i := 1; i < len(arr); i++ { if arr[i] > arr[largest] { largest = i } } return largest } func getSecondLargest(arr []int) int { first := getLargest(arr) second := -1 for i := 0; i < len(arr); i++ { if arr[first] != arr[i] { if second == -1 { second = i } else if arr[second] < arr[i] { second = i } } } return second } Efficient Approach arr[i] > arr[largest]: res = largest, largest = i arr[i] == arr[largest]: Ignore arr[i] < arr[largest]: res == -1: res = i arr[i] <= arr[res]: Ignore arr[i] > arr[res]: res = i package main import ( \"fmt\" ) func main() { arr := []int{10, 5, 6, 15} // arr := []int{30, 15, 23, 9, 28} // arr := []int{15, 15, 15} secLargest := getSecondLargest(arr) if secLargest == -1 { fmt.Println(\"No sencond largest found\") } else { fmt.Println(\"largest element at index\", secLargest) fmt.Println(\"largest element\", arr[secLargest]) } } func getSecondLargest(arr []int) int { first := 0 second := -1 for i := 1; i < len(arr); i++ { if arr[i] > arr[first] { second = first first = i } else if (second == -1 || arr[i] > arr[second]) && arr[i] != arr[first] { second = i } } return second } Time Complexity: O(n)","title":"Second Largest Element in Array"},{"location":"array/second_largest_element/#second-largest-element-in-array","text":"Input: arr[] = {10, 5, 6, 15} Output: 0 // index of 10 Input: arr[] = {30, 15, 23, 9, 28} Output: 4 // index of 28 Inpute: arr[] = {15, 15, 15} Output: -1 // No second element","title":"Second Largest Element in Array"},{"location":"array/second_largest_element/#naive-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{10, 5, 6, 15} // arr := []int{30, 15, 23, 9, 28} arr := []int{15, 15, 15} secLargest := getSecondLargest(arr) if secLargest == -1 { fmt.Println(\"No sencond largest found\") } else { fmt.Println(\"largest element at index\", secLargest) fmt.Println(\"largest element\", arr[secLargest]) } } func getLargest(arr []int) int { largest := 0 for i := 1; i < len(arr); i++ { if arr[i] > arr[largest] { largest = i } } return largest } func getSecondLargest(arr []int) int { first := getLargest(arr) second := -1 for i := 0; i < len(arr); i++ { if arr[first] != arr[i] { if second == -1 { second = i } else if arr[second] < arr[i] { second = i } } } return second }","title":"Naive Approach"},{"location":"array/second_largest_element/#efficient-approach","text":"arr[i] > arr[largest]: res = largest, largest = i arr[i] == arr[largest]: Ignore arr[i] < arr[largest]: res == -1: res = i arr[i] <= arr[res]: Ignore arr[i] > arr[res]: res = i package main import ( \"fmt\" ) func main() { arr := []int{10, 5, 6, 15} // arr := []int{30, 15, 23, 9, 28} // arr := []int{15, 15, 15} secLargest := getSecondLargest(arr) if secLargest == -1 { fmt.Println(\"No sencond largest found\") } else { fmt.Println(\"largest element at index\", secLargest) fmt.Println(\"largest element\", arr[secLargest]) } } func getSecondLargest(arr []int) int { first := 0 second := -1 for i := 1; i < len(arr); i++ { if arr[i] > arr[first] { second = first first = i } else if (second == -1 || arr[i] > arr[second]) && arr[i] != arr[first] { second = i } } return second } Time Complexity: O(n)","title":"Efficient Approach"},{"location":"linked_list/add_one_linked_list_digit/","text":"Add One in Lisked List Digit Input: |1| -> |3| -> |9| -> |9| Digit is: 1399 1399 + 1 = 1400 Output: |1| -> |4| -> |0| -> |0| Input: |9| -> |9| -> |9| -> |9| Output: |1| -> |0| -> |0| -> |0| -> |0| Implementation package main import \"fmt\" func main() { head := initialize(19999) head = addOne(head) printResult(head) } func initialize(n int) (head *Node) { var arr []int for n > 0 { data := n % 10 arr = append(arr, data) n = n / 10 } var curr *Node for i := len(arr) - 1; i >= 0; i-- { if i == len(arr)-1 { curr = &Node{data: arr[i]} head = curr } else { curr.next = &Node{data: arr[i]} curr = curr.next } } return head } func printResult(head *Node) { for head != nil { fmt.Print(head.data) head = head.next } fmt.Println() } type Node struct { data int next *Node } func addOne(head *Node) *Node { var stack []*Node curr := head for curr != nil { stack = append(stack, curr) curr = curr.next } carry := 1 for i := len(stack) - 1; i >= 0; i-- { ele := stack[i] add := ele.data + carry ele.data = add % 10 carry = add / 10 } if carry > 0 { newHead := &Node{data: carry} newHead.next = head return newHead } return head }","title":"Add One in Lisked List Digit"},{"location":"linked_list/add_one_linked_list_digit/#add-one-in-lisked-list-digit","text":"Input: |1| -> |3| -> |9| -> |9| Digit is: 1399 1399 + 1 = 1400 Output: |1| -> |4| -> |0| -> |0| Input: |9| -> |9| -> |9| -> |9| Output: |1| -> |0| -> |0| -> |0| -> |0|","title":"Add One in Lisked List Digit"},{"location":"linked_list/add_one_linked_list_digit/#implementation","text":"package main import \"fmt\" func main() { head := initialize(19999) head = addOne(head) printResult(head) } func initialize(n int) (head *Node) { var arr []int for n > 0 { data := n % 10 arr = append(arr, data) n = n / 10 } var curr *Node for i := len(arr) - 1; i >= 0; i-- { if i == len(arr)-1 { curr = &Node{data: arr[i]} head = curr } else { curr.next = &Node{data: arr[i]} curr = curr.next } } return head } func printResult(head *Node) { for head != nil { fmt.Print(head.data) head = head.next } fmt.Println() } type Node struct { data int next *Node } func addOne(head *Node) *Node { var stack []*Node curr := head for curr != nil { stack = append(stack, curr) curr = curr.next } carry := 1 for i := len(stack) - 1; i >= 0; i-- { ele := stack[i] add := ele.data + carry ele.data = add % 10 carry = add / 10 } if carry > 0 { newHead := &Node{data: carry} newHead.next = head return newHead } return head }","title":"Implementation"},{"location":"sorting/bubble_sort/","text":"Bubble Sort Bubble sort is stable It is in-place Naive Approach package main import \"fmt\" func main() { arr := []int{10, 3, 25, 17, 21, 55} bubbleSort(arr) fmt.Println(arr) } func bubbleSort(arr []int) { for i := 0; i < len(arr); i++ { for j := 0; j < len(arr)-i-1; j++ { if arr[j] > arr[j+1] { arr[j], arr[j+1] = swap(arr[j], arr[j+1]) } } } } func swap(a, b int) (int, int) { return b, a } Time Complexity: \u03b8(n*n) Efficient Approach If array is already sorted or get sorted in middle of iteration. package main import \"fmt\" func main() { // arr := []int{10, 3, 25, 17, 21, 55} arr := []int{3, 10, 17, 21, 25, 55} bubbleSort(arr) fmt.Println(arr) } func bubbleSort(arr []int) { for i := 0; i < len(arr); i++ { swapped := false for j := 0; j < len(arr)-i-1; j++ { if arr[j] > arr[j+1] { arr[j], arr[j+1] = swap(arr[j], arr[j+1]) swapped = true } } if !swapped { break } } } func swap(a, b int) (int, int) { return b, a }","title":"Bubble Sort"},{"location":"sorting/bubble_sort/#bubble-sort","text":"Bubble sort is stable It is in-place","title":"Bubble Sort"},{"location":"sorting/bubble_sort/#naive-approach","text":"package main import \"fmt\" func main() { arr := []int{10, 3, 25, 17, 21, 55} bubbleSort(arr) fmt.Println(arr) } func bubbleSort(arr []int) { for i := 0; i < len(arr); i++ { for j := 0; j < len(arr)-i-1; j++ { if arr[j] > arr[j+1] { arr[j], arr[j+1] = swap(arr[j], arr[j+1]) } } } } func swap(a, b int) (int, int) { return b, a } Time Complexity: \u03b8(n*n)","title":"Naive Approach"},{"location":"sorting/bubble_sort/#efficient-approach","text":"If array is already sorted or get sorted in middle of iteration. package main import \"fmt\" func main() { // arr := []int{10, 3, 25, 17, 21, 55} arr := []int{3, 10, 17, 21, 25, 55} bubbleSort(arr) fmt.Println(arr) } func bubbleSort(arr []int) { for i := 0; i < len(arr); i++ { swapped := false for j := 0; j < len(arr)-i-1; j++ { if arr[j] > arr[j+1] { arr[j], arr[j+1] = swap(arr[j], arr[j+1]) swapped = true } } if !swapped { break } } } func swap(a, b int) (int, int) { return b, a }","title":"Efficient Approach"},{"location":"sorting/insertion_sort/","text":"Insertion Sort O(n 2 ) In-place and stable Used in practice for small array (Tim Sort and Intro Sort) O(n) in best case Note: It divides array into two sub array. 0 to i-1 is sorted and i to n-1 is unsorted. Since 0th element already sorted in 0-0 subarray, so we have started with i=1 package main import \"fmt\" func main() { arr := []int{10, 3, 25, 17, 21, 55} // arr := []int{3, 10, 17, 21, 25, 55} insertionSort(arr) fmt.Println(arr) } func insertionSort(arr []int) { for i := 1; i < len(arr); i++ { key := arr[i] j := i - 1 for j >= 0 && arr[j] > key { arr[j+1] = arr[j] j-- } arr[j+1] = key } } Time Complexity Best Case: \u03b8(n) if already sorted Worst Case: \u03b8(n 2 ) if it is reverse sorted In General: O(n 2 )","title":"Insertion Sort"},{"location":"sorting/insertion_sort/#insertion-sort","text":"O(n 2 ) In-place and stable Used in practice for small array (Tim Sort and Intro Sort) O(n) in best case Note: It divides array into two sub array. 0 to i-1 is sorted and i to n-1 is unsorted. Since 0th element already sorted in 0-0 subarray, so we have started with i=1 package main import \"fmt\" func main() { arr := []int{10, 3, 25, 17, 21, 55} // arr := []int{3, 10, 17, 21, 25, 55} insertionSort(arr) fmt.Println(arr) } func insertionSort(arr []int) { for i := 1; i < len(arr); i++ { key := arr[i] j := i - 1 for j >= 0 && arr[j] > key { arr[j+1] = arr[j] j-- } arr[j+1] = key } } Time Complexity Best Case: \u03b8(n) if already sorted Worst Case: \u03b8(n 2 ) if it is reverse sorted In General: O(n 2 )","title":"Insertion Sort"},{"location":"sorting/introduction/","text":"Introduction Stability of Sorting Algorithm A sorting algorithm is stable if it ensures the orignal order if 2 items has same value Example of stable sorts Bubble Sort Insertion Sort Merge Sort Example of unstable sorts Selection Sort Quick Sort Heap Sorts","title":"Introduction"},{"location":"sorting/introduction/#introduction","text":"","title":"Introduction"},{"location":"sorting/introduction/#stability-of-sorting-algorithm","text":"A sorting algorithm is stable if it ensures the orignal order if 2 items has same value Example of stable sorts Bubble Sort Insertion Sort Merge Sort Example of unstable sorts Selection Sort Quick Sort Heap Sorts","title":"Stability of Sorting Algorithm"},{"location":"sorting/merge_sort/","text":"Merge Sort Introduction Divide and Conquer Algorithm Divide Conquer Merge Stable Algorithm \u03b8(n log n) time and O(n) aux space Well suited for linked list. Works in O(1) aux space Used in external sorting In generate for array. Quick sort outperforms it. Merge Two Sorted Array Naive Solution Efficient Solution Merge Function of Merge Sort Implementation Idea Implementation Merge Sort Algorithm Merge Sort Analysis","title":"Merge Sort"},{"location":"sorting/merge_sort/#merge-sort","text":"","title":"Merge Sort"},{"location":"sorting/merge_sort/#introduction","text":"Divide and Conquer Algorithm Divide Conquer Merge Stable Algorithm \u03b8(n log n) time and O(n) aux space Well suited for linked list. Works in O(1) aux space Used in external sorting In generate for array. Quick sort outperforms it.","title":"Introduction"},{"location":"sorting/merge_sort/#merge-two-sorted-array","text":"","title":"Merge Two Sorted Array"},{"location":"sorting/merge_sort/#naive-solution","text":"","title":"Naive Solution"},{"location":"sorting/merge_sort/#efficient-solution","text":"","title":"Efficient Solution"},{"location":"sorting/merge_sort/#merge-function-of-merge-sort","text":"","title":"Merge Function of Merge Sort"},{"location":"sorting/merge_sort/#implementation-idea","text":"","title":"Implementation Idea"},{"location":"sorting/merge_sort/#implementation","text":"","title":"Implementation"},{"location":"sorting/merge_sort/#merge-sort-algorithm","text":"","title":"Merge Sort Algorithm"},{"location":"sorting/merge_sort/#merge-sort-analysis","text":"","title":"Merge Sort Analysis"},{"location":"sorting/selection_sort/","text":"Selection Sort \u03b8(n 2 ) Algorithm Does less memory writes compared to quick sort, merge sort, insertion sor etc. But cycle sort is optimal in terms of memory writes Basic idea for heap sort Not stable In place: Does not require extra memory for sorting package main import \"fmt\" func main() { arr := []int{10, 3, 25, 17, 21, 55} // arr := []int{3, 10, 17, 21, 25, 55} selectionSort(arr) fmt.Println(arr) } func selectionSort(arr []int) { for i := 0; i < len(arr)-1; i++ { min_idx := i for j := i + 1; j < len(arr); j++ { if arr[j] < arr[min_idx] { min_idx = j } } arr[i], arr[min_idx] = arr[min_idx], arr[i] } } Time Complexity : \u03b8(n 2 ) Q. Why is it not stable. Ans: Given an array: arr[] = {90, 95, 90, 101 } 90 at 0th index will be swapped with 90 at 3rd index. So orginal order is not maintain when two elements are equal.","title":"Selection Sort"},{"location":"sorting/selection_sort/#selection-sort","text":"\u03b8(n 2 ) Algorithm Does less memory writes compared to quick sort, merge sort, insertion sor etc. But cycle sort is optimal in terms of memory writes Basic idea for heap sort Not stable In place: Does not require extra memory for sorting package main import \"fmt\" func main() { arr := []int{10, 3, 25, 17, 21, 55} // arr := []int{3, 10, 17, 21, 25, 55} selectionSort(arr) fmt.Println(arr) } func selectionSort(arr []int) { for i := 0; i < len(arr)-1; i++ { min_idx := i for j := i + 1; j < len(arr); j++ { if arr[j] < arr[min_idx] { min_idx = j } } arr[i], arr[min_idx] = arr[min_idx], arr[i] } } Time Complexity : \u03b8(n 2 ) Q. Why is it not stable. Ans: Given an array: arr[] = {90, 95, 90, 101 } 90 at 0th index will be swapped with 90 at 3rd index. So orginal order is not maintain when two elements are equal.","title":"Selection Sort"},{"location":"string/anagram/","text":"Check If Two Given Strings are Anagram or Not Example of anagram strings: Listen == Silent Triangle == Integral William Shakespeare == I am a weakish speller Note: The string may contain punctuations. You need to ignore punctuations Implementation","title":"Strign is Anagram"},{"location":"string/anagram/#check-if-two-given-strings-are-anagram-or-not","text":"Example of anagram strings: Listen == Silent Triangle == Integral William Shakespeare == I am a weakish speller Note: The string may contain punctuations. You need to ignore punctuations","title":"Check If Two Given Strings are Anagram or Not"},{"location":"string/anagram/#implementation","text":"","title":"Implementation"},{"location":"string/max_word_n_count/","text":"Max occured word by d in given paragraph","title":"Max n Occurance of Word in Paragraph"},{"location":"string/max_word_n_count/#max-occured-word-by-d-in-given-paragraph","text":"","title":"Max occured word by d in given paragraph"},{"location":"string/palindrom/","text":"Check if a String is Palindrom or not Efficient Approach package main import \"fmt\" func main() { str := \"\u65e5\u672c\u8a9e\u672c\u65e5\" // true // str := \"\u65e5\u672c\u8a9e\u8a9e\u672c\" // false // str := \"\u65e5\u672c\u8a9e\u8a9e\u672c\u65e5\" // true // str := \"madam\" // true // str := \"maddam\" // true result := isPalindram(str) fmt.Println(result) } func isPalindram(str string) bool { chars := []rune(str) for i := 0; i < len(chars)/2; i++ { revIdx := len(chars) - i - 1 if chars[i] != chars[revIdx] { return false } } return true }","title":"String is Palindrom"},{"location":"string/palindrom/#check-if-a-string-is-palindrom-or-not","text":"","title":"Check if a String is Palindrom or not"},{"location":"string/palindrom/#efficient-approach","text":"package main import \"fmt\" func main() { str := \"\u65e5\u672c\u8a9e\u672c\u65e5\" // true // str := \"\u65e5\u672c\u8a9e\u8a9e\u672c\" // false // str := \"\u65e5\u672c\u8a9e\u8a9e\u672c\u65e5\" // true // str := \"madam\" // true // str := \"maddam\" // true result := isPalindram(str) fmt.Println(result) } func isPalindram(str string) bool { chars := []rune(str) for i := 0; i < len(chars)/2; i++ { revIdx := len(chars) - i - 1 if chars[i] != chars[revIdx] { return false } } return true }","title":"Efficient Approach"},{"location":"string/pangram/","text":"Check if a String is Pangram or not A string is pangram if string contain a-z / A-Z alphabets alteast once. You can ignore the case. You need to consider only english alphabets and the string may contain punctuation marks. Also, you need to return how number of letter are missing if it is not pangram. Example of angram string: 1. The quick brown fox jumps over a lazy dog. 2. Mr. Jock, TV quiz PhD., bags few lynx. Initial Solution package main import ( \"fmt\" \"strings\" ) func main() { str := \"The quick brown fox jumps over a lazy dog.\" // true 0 // str := \"Mr. Jock, TV quiz PhD., bags few lynx.\" // true 0 // str := \"The quick brown fox jumps over the dog\" // false 4 result, count := isPangram(str) fmt.Println(result, count) } func isPangram(str string) (bool, int) { charMap := make(map[string]bool) for _, ele := range str { if (ele >= 'A' && ele <= 'Z') || (ele >= 'a' && ele <= 'z') { char := strings.ToLower(string(ele)) charMap[char] = true } } if len(charMap) == 26 { return true, 0 } return false, 26 - len(charMap) } Enhancement It should also show missing letters. package main import ( \"fmt\" \"strings\" ) func main() { // str := \"The quick brown fox jumps over a lazy dog.\" // true [] // str := \"Mr. Jock, TV quiz PhD., bags few lynx.\" // true [] str := \"The quick brown fox jumps over the dog\" // false [a l y z] result, count := isPangram(str) fmt.Println(result, count) } func isPangram(str string) (bool, []string) { charMap := make(map[string]bool) for _, ele := range str { if (ele >= 'A' && ele <= 'Z') || (ele >= 'a' && ele <= 'z') { char := strings.ToLower(string(ele)) charMap[char] = true } } var missingAlpha []string var i rune = 'a' for ; i <= 'z'; i++ { if !(charMap[string(i)]) { missingAlpha = append(missingAlpha, string(i)) } } if len(missingAlpha) == 0 { return true, missingAlpha } return false, missingAlpha }","title":"String is Pangram"},{"location":"string/pangram/#check-if-a-string-is-pangram-or-not","text":"A string is pangram if string contain a-z / A-Z alphabets alteast once. You can ignore the case. You need to consider only english alphabets and the string may contain punctuation marks. Also, you need to return how number of letter are missing if it is not pangram. Example of angram string: 1. The quick brown fox jumps over a lazy dog. 2. Mr. Jock, TV quiz PhD., bags few lynx.","title":"Check if a String is Pangram or not"},{"location":"string/pangram/#initial-solution","text":"package main import ( \"fmt\" \"strings\" ) func main() { str := \"The quick brown fox jumps over a lazy dog.\" // true 0 // str := \"Mr. Jock, TV quiz PhD., bags few lynx.\" // true 0 // str := \"The quick brown fox jumps over the dog\" // false 4 result, count := isPangram(str) fmt.Println(result, count) } func isPangram(str string) (bool, int) { charMap := make(map[string]bool) for _, ele := range str { if (ele >= 'A' && ele <= 'Z') || (ele >= 'a' && ele <= 'z') { char := strings.ToLower(string(ele)) charMap[char] = true } } if len(charMap) == 26 { return true, 0 } return false, 26 - len(charMap) }","title":"Initial Solution"},{"location":"string/pangram/#enhancement","text":"It should also show missing letters. package main import ( \"fmt\" \"strings\" ) func main() { // str := \"The quick brown fox jumps over a lazy dog.\" // true [] // str := \"Mr. Jock, TV quiz PhD., bags few lynx.\" // true [] str := \"The quick brown fox jumps over the dog\" // false [a l y z] result, count := isPangram(str) fmt.Println(result, count) } func isPangram(str string) (bool, []string) { charMap := make(map[string]bool) for _, ele := range str { if (ele >= 'A' && ele <= 'Z') || (ele >= 'a' && ele <= 'z') { char := strings.ToLower(string(ele)) charMap[char] = true } } var missingAlpha []string var i rune = 'a' for ; i <= 'z'; i++ { if !(charMap[string(i)]) { missingAlpha = append(missingAlpha, string(i)) } } if len(missingAlpha) == 0 { return true, missingAlpha } return false, missingAlpha }","title":"Enhancement"},{"location":"string/word_count/","text":"Word count(ocurance of each word) in given paragraph","title":"Word cound in paragraph"},{"location":"string/word_count/#word-countocurance-of-each-word-in-given-paragraph","text":"","title":"Word count(ocurance of each word) in given paragraph"}]}